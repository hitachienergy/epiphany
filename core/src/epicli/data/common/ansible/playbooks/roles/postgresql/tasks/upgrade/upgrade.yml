---
# Upgrade procedure based on steps from: https://www.postgresql.org/docs/13/pgupgrade.html

# Disabling extensions is not supported, so these values are taken by check whether related packages are installed
# It's possible to take these values from manifest, but as it can be overwritten, values are based on packages
- name: PostgreSQL | Set facts on installed extensions
  set_fact:
    pg_is_pgaudit_used: "{{ ansible_facts.packages.keys() | intersect(_packages.pgaudit) | count > 0 }}"
    pg_is_repmgr_used: "{{ ansible_facts.packages.keys() | intersect(_packages.repmgr)  | count > 0 }}"
    pg_is_pgbouncer_used: "{{ ansible_facts.packages.pgbouncer is defined }}" # package name is the same for all versions
  vars:
    _packages:
      pgaudit:
        - "{{ old_version.pgaudit.package_name[ansible_os_family] }}"
        - "{{ new_version.pgaudit.package_name[ansible_os_family] }}"
      repmgr:
        - "{{ old_version.repmgr.package_name[ansible_os_family] }}"
        - "{{ new_version.repmgr.package_name[ansible_os_family] }}"

- name: PostgreSQL | Get primary node
  when: pg_is_repmgr_used
  become_user: postgres
  shell: |-
    set -o pipefail && \
    {{ old_version.repmgr.bin_dir[ansible_os_family] }}/repmgr cluster show \
      | awk 'BEGIN{FS="|"} {gsub(/ /,""); if ($3 == "primary") print $2}'
  changed_when: false
  register: pg_primary_node_found
  # when there are two primary nodes (after failover) rc is non-zero
  failed_when: pg_primary_node_found.rc != 0 or pg_primary_node_found.stdout == ""
  run_once: true

# 'pg_primary_node' fact should be available for upgrade and rollback
- name: PostgreSQL | Set 'pg_primary_node' fact
  set_fact:
    pg_primary_node: "{{ pg_primary_node_found.stdout | default('') }}"

# postgresql_info module doesn't display tablespace locations, so it's requested
- name: PostgreSQL | Query custom tablespaces
  become_user: postgres
  postgresql_query:
    query: "select pg_tablespace_location(oid) as location from pg_tablespace where spcname not in ('pg_default', 'pg_global')"
  delegate_to: "{{ pg_primary_node }}"
  run_once: true
  register: pg_custom_tablespaces

- name: PostgreSQL | Set 'pg_custom_tablespace_locations' fact
  set_fact:
    pg_custom_tablespace_locations: "{{ pg_custom_tablespaces.query_result | map(attribute='location') | list }}"

- name: PostgreSQL | Upgrade
  block:
    # Step: Install the new PostgreSQL binaries

    # Ubuntu: automatically creates 'main' cluster and starts postgresql services
    # RHEL/CentOS: cluster name is empty, service is not started
    - name: PostgreSQL | Install package(s)
      package:
        name: "{{ _packages[ansible_os_family] }}"
        state: present
      vars:
        _packages:
          Debian:
            - postgresql-client-common
            - postgresql-common
            - "postgresql-client-{{ new_version.pg.version }}"
            - "postgresql-{{ new_version.pg.version }}"
          RedHat:
            - "postgresql{{ new_version.pg.version }}-server"
      module_defaults:
        yum: { lock_timeout: "{{ yum_lock_timeout }}" }

    # Step: Initialize the new PostgreSQL cluster (on Ubuntu done automatically)

    # This value is default but set explicitly to avoid errors
    - name: PostgreSQL | Ensure that PG {{ new_version.pg.version }} data directory has correct permissions
      file:
        path: "{{ new_version.pg.data_dir[ansible_os_family] }}"
        state: directory
        owner: postgres
        group: postgres
        mode: u=rwx,g=,o= # Permissions should be u=rwx (0700) or u=rwx,g=rx (0750)

    # Database doesn't initialize automatically during second run (after rollback)
    - name: PostgreSQL | Debian | Check if database is initialized
      when: ansible_os_family != 'RedHat'
      stat:
        path: "{{ new_version.pg.data_dir[ansible_os_family] }}/PG_VERSION"
        get_attributes: false
        get_checksum: false
        get_mime: false
      register: stat_pg_version_file

    - name: PostgreSQL | Initialize database
      when: ansible_os_family == 'RedHat' or not stat_pg_version_file.stat.exists
      command: "{{ new_version.pg.bin_dir[ansible_os_family] }}/initdb"
      become_user: postgres
      environment:
        PGDATA: "{{ new_version.pg.data_dir[ansible_os_family] }}"

    # Step: Install custom shared object files

    - name: PostgreSQL | Extensions | PgAudit | Include package(s) installation tasks
      include_tasks: roles/postgresql/tasks/upgrade/extensions/pgaudit/packages.yml
      when: pg_is_pgaudit_used

    - name: PostgreSQL | Extensions | PgBouncer | Upgrade
      when: pg_is_pgbouncer_used
      block:
        - include_tasks: roles/postgresql/tasks/upgrade/extensions/pgbouncer/packages.yml

        - name: Extensions | PgBouncer | Ensure that systemd service is started
          systemd:
            name: pgbouncer
            state: started

    - name: Stop and disable repmgr service then install new package(s)
      when: pg_is_repmgr_used
      block:
        - include_tasks: roles/postgresql/tasks/upgrade/extensions/replication/pg-new/repmgr-stop-and-disable-service.yml

        - name: PostgreSQL | Extensions | repmgr | Include package(s) installation tasks
          include_tasks: roles/postgresql/tasks/upgrade/extensions/replication/pg-new/packages.yml

    # Step: Adjust authentication
    - name: PostgreSQL | Extensions | repmgr | Update pgpass file
      when: pg_is_repmgr_used
      vars:
        _replication_user_name: "{{ upgrade_vars.specification.extensions.replication.replication_user_name }}"
        _replication_user_password: "{{ upgrade_vars.specification.extensions.replication.replication_user_password }}"
        _privileged_user_name: "{{ upgrade_vars.specification.extensions.replication.privileged_user_name }}"
        _privileged_user_password: "{{ upgrade_vars.specification.extensions.replication.privileged_user_password }}"
      template:
        src: pgpass-repmgr.j2
        dest: "{{ new_version.pg.base_dir[ansible_os_family] }}/.pgpass"
        owner: postgres
        group: postgres
        mode: u=rw,g=,o=

    # Step: Stop all servers
    # Standby nodes have to be stopped after primary. Check p.8 from https://www.postgresql.org/docs/13/pgupgrade.html

    - name: PostgreSQL | Stop PostgreSQL services on primary node
      when: (pg_is_repmgr_used and inventory_hostname == pg_primary_node) or not pg_is_repmgr_used
      <<: &stop_pg_services
        systemd:
          name: "{{ service_name }}"
          state: stopped
        loop_control:
          loop_var: service_name
        loop:
          - "{{ old_version.pg.service_name[ansible_os_family] }}"  # the same name for both versions
          - "{{ old_version.pg.instantiated_service_name[ansible_os_family] }}"
          - "{{ new_version.pg.instantiated_service_name[ansible_os_family] }}"

    - name: PostgreSQL | Stop PostgreSQL services on standby nodes
      when:
        - pg_is_repmgr_used
        - inventory_hostname != pg_primary_node
      <<: *stop_pg_services

    # Step: Run pg_upgrade

    # Process the same configuration files as for 'apply'
    - name: PostgreSQL | Copy configuration files
      block:
        - name: PostgreSQL | Copy configuration files
          vars:
            _files:
              - pg_hba.conf
              - postgresql-epiphany.conf
              - postgresql.conf
            _pg_data_dir: "{{ new_version.pg.data_dir[ansible_os_family] }}" # used in postgresql.conf
            _extensions:
              extensions:
                pgaudit:
                  enabled: "{{ pg_is_pgaudit_used }}"
                replication:
                  enabled: "{{ pg_is_repmgr_used }}"
            # Values from manifest are used when it's not possible to do changes after 'apply'
            # such as enabling/disabling extensions
            _specification: "{{ upgrade_vars.specification | combine(_extensions, recursive=True) }}"
          template:
            src: "roles/postgresql/templates/{{ file_name }}.j2"
            dest: "{{ new_version.pg.config_dir[ansible_os_family] }}/{{ file_name }}"
            owner: postgres
            group: postgres
            mode: u=rw,g=,o=
            backup: true
          loop_control:
            loop_var: file_name
          loop: "{{ _files }}"

        - name: PostgreSQL | Extensions | repmgr | Copy configuration file
          when: pg_is_repmgr_used
          include_tasks: roles/postgresql/tasks/upgrade/extensions/replication/pg-new/repmgr-conf.yml

    - name: PostgreSQL | Upgrade primary node
      when: (pg_is_repmgr_used and inventory_hostname == pg_primary_node) or not pg_is_repmgr_used
      block:
        # --link is not used to be able to access old cluster once the new one is started after the upgrade
        # there is a preflight check to confirm that available disk space is enough
        # --clone is not used as only Btrfs and XFS file systems are supported for the current version
        # also with file copying there is an ability to create new data directory not on the same file system
        - name: PostgreSQL | Run pg_upgrade
          become_user: postgres
          module_defaults:
            shell:
              chdir: "{{ _upgrade_working_dir }}"  # 'pg_upgrade' creates scripts in the current directory
              executable: /bin/bash
          vars:
            _new_version_config_dir: "{{ new_version.pg.config_dir[ansible_os_family] }}"  # to make command shorter
            _pg_upgrade_log_filenames:
              check: pg_upgrade-check-{{ ansible_date_time.iso8601_basic_short | replace('T','-') }}.log
              main: pg_upgrade-{{ ansible_date_time.iso8601_basic_short | replace('T','-') }}.log
            _upgrade_working_dir: "{{ new_version.pg.base_dir[ansible_os_family] }}/upgrade/{{ new_version.pg.version }}"
          block:
            - name: PostgreSQL | Create working directory for pg_upgrade
              file:
                path: "{{ _upgrade_working_dir }}"
                state: directory
                mode: u=rwx,go=rx

            # This check is not in the 'preflight' as at that stage new version is not available
            # Checks:
            #   * cluster versions
            #   * database user is the install user
            #   * database connection settings
            #   * prepared transactions
            #   * system-defined composite types in user tables
            #   * reg* data types in user tables
            #   * contrib/isn with bigint-passing mismatch
            #   * tables WITH OIDS
            #   * invalid "sql_identifier" user columns
            #   * presence of required libraries
            #   * database user is the install user
            #   * prepared transactions
            #   * new cluster tablespace directories
            - name: PostgreSQL | Run pg_upgrade with --check
              shell: >-
                set -o pipefail &&
                {{ new_version.pg.bin_dir[ansible_os_family] }}/pg_upgrade
                --old-datadir {{ old_version.pg.data_dir[ansible_os_family] }}
                --new-datadir {{ new_version.pg.data_dir[ansible_os_family] }}
                --old-bindir {{ old_version.pg.bin_dir[ansible_os_family] }}
                --new-bindir {{ new_version.pg.bin_dir[ansible_os_family] }}
                --old-options '-c config_file={{ old_version.pg.config_dir[ansible_os_family] }}/postgresql.conf'
                --new-options '-c config_file={{ _new_version_config_dir }}/postgresql.conf -c hba_file={{ _new_version_config_dir }}/pg_hba.conf'
                --socketdir /var/run/postgresql
                --jobs {{ ansible_processor_vcpus }}
                --check |&
                tee {{ _log_filename }}; status=$?;
                chmod go= {{ _log_filename }} && exit $status
              register: pg_upgrade_check
              vars:
                _log_filename: "{{ _pg_upgrade_log_filenames.check }}"

            - name: PostgreSQL | Print pg_upgrade check output
              debug:
                var: pg_upgrade_check.stdout_lines

            - name: PostgreSQL | Run pg_upgrade
              shell: >-
                {{ new_version.pg.bin_dir[ansible_os_family] }}/pg_upgrade
                --old-datadir {{ old_version.pg.data_dir[ansible_os_family] }}
                --new-datadir {{ new_version.pg.data_dir[ansible_os_family] }}
                --old-bindir {{ old_version.pg.bin_dir[ansible_os_family] }}
                --new-bindir {{ new_version.pg.bin_dir[ansible_os_family] }}
                --old-options '-c config_file={{ old_version.pg.config_dir[ansible_os_family] }}/postgresql.conf'
                --new-options '-c config_file={{ _new_version_config_dir }}/postgresql.conf -c hba_file={{ _new_version_config_dir }}/pg_hba.conf'
                --socketdir /var/run/postgresql
                --jobs {{ ansible_processor_vcpus }} >> {{ _log_filename }} 2>&1; status=$?;
                chmod go= {{ _log_filename }} && exit $status
              vars:
                _log_filename: "{{ _pg_upgrade_log_filenames.main }}"

            - name: PostgreSQL | Print a note to check upgrade results
              debug:
                msg:
                  - '**************************************'
                  - Check {{ _upgrade_working_dir }}/{{ _pg_upgrade_log_filenames.main }} on host {{ inventory_hostname }} for upgrade results.
                  - If pg_upgrade generated any .sql files in {{ _upgrade_working_dir }}, run them.
                  - 'For more information, refer to PostgreSQL docs ("Post-upgrade processing" step):'
                  - https://www.postgresql.org/docs/13/pgupgrade.html
                  - '**************************************'

        - name: PostgreSQL | Start PostgreSQL {{ new_version.pg.version }} service
          block:
            - name: PostgreSQL | Debian | Mask {{ old_version.pg.instantiated_service_name.Debian }} service to avoid port conflict
              when: ansible_os_family == 'Debian'
              systemd:
                name: "{{ old_version.pg.instantiated_service_name[ansible_os_family] }}"
                masked: true

            - name: PostgreSQL | Start PostgreSQL {{ new_version.pg.version }} service
              systemd:
                name: "{{ new_version.pg.service_name[ansible_os_family] }}"
                state: started

            - name: PostgreSQL | Debian | Ensure that instantiated PostgreSQL {{ new_version.pg.version }} service started
              when: ansible_os_family == 'Debian'
              systemd:
                name: "{{ new_version.pg.instantiated_service_name[ansible_os_family] }}"
                state: started

        - name: PostgreSQL | Extensions | repmgr | Register primary node
          when: pg_is_repmgr_used
          include_tasks: roles/postgresql/tasks/upgrade/extensions/replication/pg-new/repmgr-register-primary.yml

    # Step: Upgrade standby servers
    - name: Upgrade standby nodes
      when:
        - pg_is_repmgr_used
        - inventory_hostname != pg_primary_node
      block:
        # Do not clone standby if there is no new PG running on primary node (upgrade failed)
        - name: PostgreSQL | Check if PostgreSQL {{ new_version.pg.version }} is running on primary node
          postgresql_info:
            filter: version
          register: primary_node_pg_info
          become: true
          become_user: postgres
          delegate_to: "{{ pg_primary_node }}"

        - name: Assert PostgreSQL version on primary node
          assert:
            that: primary_node_pg_info.version.major == new_version.pg.version
            quiet: true

        - name: PostgreSQL | Upgrade standby servers (clone standby node from primary and register)
          include_tasks: roles/postgresql/tasks/upgrade/extensions/replication/pg-new/repmgr-register-standby.yml

    - name: PostgreSQL | Disable {{ _old_pg_service }} service
      when: _old_pg_service != new_version.pg.service_name[ansible_os_family]
      systemd:
        name: "{{ _old_pg_service }}"
        enabled: false
      vars:
        _old_pg_service: "{{ old_version.pg.service_name[ansible_os_family] }}"

    - name: PostgreSQL | Enable {{ _new_pg_service }} service
      systemd:
        name: "{{ _new_pg_service }}"
        enabled: true
      vars:
        _new_pg_service: "{{ new_version.pg.service_name[ansible_os_family] }}"

    - name: PostgreSQL | Extensions | repmgr | RedHat | Update repmgr symlink
      when:
        - ansible_os_family == 'RedHat'
        - pg_is_repmgr_used
      file:
        src: "{{ new_version.repmgr.bin_dir.RedHat }}/repmgr"
        dest: "/usr/bin/repmgr"
        state: link

    - name: PostgreSQL | Extensions | repmgr | Debian | Update REPMGRD_CONF in /etc/default/repmgrd
      when:
        - ansible_os_family == 'Debian'
        - pg_is_repmgr_used
      replace:
        path: /etc/default/repmgrd
        regexp: ^REPMGRD_CONF=\"/etc/postgresql/{{ old_version.pg.version }}/main/repmgr.conf\"
        replace: REPMGRD_CONF="/etc/postgresql/{{ new_version.pg.version }}/main/repmgr.conf"

    # Start and enable repmgr service
    - include_tasks: roles/postgresql/tasks/upgrade/extensions/replication/pg-new/repmgr-start-and-enable-service.yml
      when: pg_is_repmgr_used

  # Step: Reverting to old cluster
  rescue:
    - name: Rollback | Get service facts
      service_facts:

    - name: Rollback | Extensions | repmgr | Stop all repmgr services
      when: ansible_facts.services[service_name + '.service'] is defined
      systemd:
        name: "{{ service_name }}"
        state: stopped
      loop_control:
        loop_var: service_name
      loop: "{{ _services | unique }}"
      vars:
        _services:
          - "{{ old_version.repmgr.service_name[ansible_os_family] }}"
          - "{{ new_version.repmgr.service_name[ansible_os_family] }}"

    - name: Rollback | Extensions | repmgr | Disable {{ _service }} service
      when:
        - _service != old_version.repmgr.service_name[ansible_os_family]
        - ansible_facts.services[_service + '.service'] is defined
      systemd:
        name: "{{ _service }}"
        enabled: false
      vars:
        _service: "{{ new_version.repmgr.service_name[ansible_os_family] }}"

    - name: Restore repmgr symlinks
      when: pg_is_repmgr_used
      block:
        - name: Rollback | Extensions | repmgr | RedHat | Update repmgr symlink
          file:
            src: "{{ old_version.repmgr.bin_dir.RedHat }}/repmgr"
            dest: "/usr/bin/repmgr"
            state: link
          when: ansible_os_family == 'RedHat'

        - name: Rollback | Extensions | repmgr | Debian | Update symlink to config file
          file:
            src: "{{ old_version.repmgr.config_dir[ansible_os_family] }}/repmgr.conf"
            dest: /etc/repmgr.conf
            state: link
          when: ansible_os_family == 'Debian'

    - name: Stop and disable new PostgreSQL service
      block:
        - name: Rollback | Stop PG {{ new_version.pg.version }} service
          when: ansible_facts.services[service_name + '.service'] is defined
          systemd:
            name: "{{ service_name }}"
            state: stopped
          loop_control:
            loop_var: service_name
          loop: "{{ _services | reject('==', '') }}"
          vars:
            _services:
              - "{{ new_version.pg.service_name[ansible_os_family] }}"
              - "{{ new_version.pg.instantiated_service_name[ansible_os_family] }}"

        - name: Rollback | Disable PG {{ new_version.pg.version }} service
          when:
            - ansible_facts.services[service_name + '.service'] is defined
            - service_name != old_version.pg.service_name[ansible_os_family]
          systemd:
            name: "{{ service_name }}"
            enabled: false
            masked: "{{ True if (service_name == new_version.pg.instantiated_service_name[ansible_os_family]) else False }}"
          loop_control:
            loop_var: service_name
          loop: "{{ _services | reject('==', '') }}"
          vars:
            _services:
              - "{{ new_version.pg.service_name[ansible_os_family] }}"
              - "{{ new_version.pg.instantiated_service_name[ansible_os_family] }}"

    - name: Rollback | Remove PG {{ new_version.pg.version }} data directory
      file:
        path: "{{ new_version.pg.data_dir[ansible_os_family] }}"
        state: absent

    - name: Rollback | Clean up migrated tablespace directories
      vars:
        pattern: "PG_{{ new_version.pg.version }}_*"
      include_tasks: roles/postgresql/tasks/helpers/rm-dir-content.yml
      loop_control:
        loop_var: directory_path
      loop: "{{ pg_custom_tablespace_locations }}"

    - name: Rollback | Remove PG {{ new_version.pg.version }} related packages
      package:
        name: "{{ _packages[ansible_os_family] }}"
        state: absent
      vars:
        _packages:
          Debian:
            - "postgresql-client-{{ new_version.pg.version }}"
            - "postgresql-{{ new_version.pg.version }}"
            - "{{ new_version.pgaudit.package_name.Debian }}"
            - "{{ new_version.repmgr.package_name.Debian }}"
          RedHat:
            - "postgresql{{ new_version.pg.version }}-server"
            - "{{ new_version.pgaudit.package_name.RedHat }}"
            - "{{ new_version.repmgr.package_name.RedHat }}"
      module_defaults:
        yum: { lock_timeout: "{{ yum_lock_timeout }}" }

    - name: Rollback | Extensions | repmgr | Debian | Restore REPMGRD_CONF in /etc/default/repmgrd
      when:
        - ansible_os_family == 'Debian'
        - pg_is_repmgr_used
      replace:
        path: /etc/default/repmgrd
        regexp: ^REPMGRD_CONF=\"/etc/postgresql/{{ new_version.pg.version }}/main/repmgr.conf\"
        replace: REPMGRD_CONF="/etc/postgresql/{{ old_version.pg.version }}/main/repmgr.conf"

    - name: Rollback | Start PG {{ old_version.pg.version }} service
      systemd:
        name: "{{ service_name }}"
        state: started
        masked: false
      loop_control:
        loop_var: service_name
      loop: "{{ _services | reject('==', '') }}"
      vars:
        _services:
          - "{{ old_version.pg.service_name[ansible_os_family] }}"
          - "{{ old_version.pg.instantiated_service_name[ansible_os_family] }}"

    - name: Rollback | Enable {{ _service }} service
      systemd:
        name: "{{ _service }}"
        enabled: true
      vars:
        _service: "{{ old_version.pg.service_name[ansible_os_family] }}"

    - name: Start and enable old repmgr service
      when: pg_is_repmgr_used
      block:
        - name: Rollback | Extensions | repmgr | Gather info about runnimg PG version from all nodes
          when: pg_is_repmgr_used
          postgresql_info:
            filter: version
          register: pg_info
          ignore_errors: true  # PostgreSQL service may be stopped
          become: true
          become_user: postgres
          delegate_to: "{{ node }}"
          loop_control:
            loop_var: node
          loop: "{{ ansible_play_hosts_all }}"

        - name: Rollback | Extensions | repmgr | Set 'start_old_repmgr' fact  # true when all nodes have the same PG version running
          set_fact:
            start_old_repmgr: "{{ pg_info.results | rejectattr('failed')
                                                  | selectattr('version.major', '==', old_version.pg.version)
                                                  | count == ansible_play_hosts_all | count }}"

        - name: Rollback | Extensions | repmgr | Start and enable {{ _service }} service on all nodes
          when: start_old_repmgr
          systemd:
            name: "{{ _service }}"
            state: started
            enabled: true
          delegate_to: "{{ node }}"
          vars:
            _service: "{{ old_version.repmgr.service_name[ansible_os_family] }}"
          loop_control:
            loop_var: node
          loop: "{{ ansible_play_hosts_all }}"

        - name: Rollback | Extensions | repmgr | Print warning
          when: not start_old_repmgr
          debug:
            msg:
              - '**************************************'
              - "WARN: At least on one node running PostgreSQL {{ old_version.pg.version }} was not found."
              - "WARN: Thus {{ old_version.repmgr.service_name[ansible_os_family] }} service was not started nor enabled by rollback."
              - "WARN: Check PostgreSQL version and service status on all nodes manually."
              - "WARN: After having consistent cluster state, you may want to start and enable the service on all nodes."
              - '**************************************'

    - name: PostgreSQL | Fail upgrade with a note
      fail:
        msg: PostgreSQL upgrade failed, please check logs
