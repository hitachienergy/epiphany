---
apiVersion: v1
kind: ConfigMap
metadata:
  name: pgpool-container-env
  labels:
    app: pgpool
  namespace: {{ data.namespace }}
data:
{% if data.pgpool.env.PGPOOL_BACKEND_NODES is undefined or data.pgpool.env.PGPOOL_BACKEND_NODES|lower == 'autoconfigured' %}
  PGPOOL_BACKEND_NODES: "{% for node in groups['postgresql'] %}{{ loop.index0 }}:{{ hostvars[groups['postgresql'][loop.index0]].ansible_hostname }}:5432{% if not loop.last %},{% endif %}{% endfor %}"
{% else %}
  PGPOOL_BACKEND_NODES: "{{ data.pgpool.env.PGPOOL_BACKEND_NODES }}"
{% endif %}
{% for env_var, value in data.pgpool.env.items() if env_var not in ["PGPOOL_BACKEND_NODES"] %}
{#   convert boolean to 'yes' or 'no' to meet requirements #}
{%   if value is sameas true or value is sameas false %}
{%     set value = value | ternary('yes', 'no') %}
{%   endif %}
  {{ env_var }}: "{{ value }}"
{% endfor %}

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: pgpool-init-scripts
  labels:
    app: pgpool
  namespace: {{ data.namespace }}
data:
  init_pool_passwd_file.sh: |
    #!/bin/bash

    set -o errexit
    set -o nounset
    set -o pipefail

    echo "==> Started: $0"

    # ----------------------
    # Arguments:
    #   output_file_path | default=/epiphany/shared_dir/pool_passwd
    # ----------------------
    main() {
      local -r users_with_passwords_query="SELECT rolname||':'||rolpassword FROM pg_authid WHERE rolpassword IS NOT NULL"
      local -r output_file=${1:-/epiphany/shared_dir/pool_passwd}

      validate_env

      # User with SELECT on pg_authid table privilege is required (or SUPERUSER)
      export PGUSER="${PGPOOL_POSTGRES_USERNAME}"
      export PGPASSWORD="$(< "${PGPOOL_POSTGRES_PASSWORD_FILE}")"

      test_connection "$(get_connection_string 15)" || fail "Connection test failed"

      echo "Running query: '${users_with_passwords_query}'..."
      local query_result="$(run_sql "${users_with_passwords_query}" "$(get_connection_string 15)")" || fail "psql failed"

      echo "Fetched rows: $(printf '%s\n' "${query_result}" | wc -l)"

      if test -n "${query_result}"; then
        if ! test -f ${output_file}; then
          echo "Creating '${output_file}' file..."
        else
          echo "Updating '${output_file}' file..."
        fi
        cat <<< "${query_result}" > $output_file \
          && echo "Done"
      else
        fail "No rows in query result"
      fi
    }

    validate_env() {
      # Fail if password file does not exist
      test -f "${PGPOOL_POSTGRES_PASSWORD_FILE}" || fail "PGPOOL_POSTGRES_PASSWORD_FILE='${PGPOOL_POSTGRES_PASSWORD_FILE}' not found"

      # Fail if PGPOOL_BACKEND_NODES is empty
      test -n "${PGPOOL_BACKEND_NODES}" || fail "PGPOOL_BACKEND_NODES cannot be empty"
    }

    fail() {
      local -r error_message=${1:?error_message is missing}

      echo ""
      echo "ERROR: $error_message" 1>&2 && exit 1
    }

    # ----------------------
    # Arguments:
    #   connect_timeout | default=15 | maximum wait for connection in seconds
    # Returns:
    #   connection_string
    # ----------------------
    get_connection_string() {
      local -r connect_timeout=${1:-15}
      local -a hosts
      local -a ports

      read -r -a nodes <<< "$(tr ',;' ' ' <<< "${PGPOOL_BACKEND_NODES}")"
      for node in "${nodes[@]}"; do
        read -r -a fields <<< "$(tr ':' ' ' <<< "${node}")"
        hosts+=(${fields[1]})
        ports+=(${fields[2]})
      done

      join() { local IFS=","; echo "$*"; }
      echo "host=$(join ${hosts[@]}) port=$(join ${ports[@]}) dbname=postgres connect_timeout=$connect_timeout"
    }

    # ----------------------
    # Arguments:
    #   connection_string
    # Returns:
    #   0 when OK
    #   1 when failed
    # There is no pg_isready in the container so psql is used
    # ----------------------
    test_connection() {
      local -r connection_string=${1:?connection_string is missing}

      echo "Testing connection to postgres database [conninfo: '$connection_string']..."
      # psql returns 0 if finished normally, 1 if fatal error occurs, 2 if connection to server went bad and session was not interactive
      if psql --no-password -d "$connection_string" -c "SELECT 1" >/dev/null; then
        echo "Test OK"
        return 0
      else
        echo "Test FAILED"
        return 1
      fi
    }

    # ----------------------
    # Arguments:
    #   sql_query
    #   connection_string
    # Returns:
    #   result_string
    # ----------------------
    run_sql() {
      local -r sql_query=${1:?sql_query is missing}
      local -r connection_string=${2:?connection_string is missing}
      psql --no-password -d "$connection_string" --tuples-only --no-align -c "$sql_query"
    }

    main "$@"

    echo "==> Completed: $0"

{# --- init_pcp_conf.sh --- #}

  init_pcp_conf.sh: |
    #!/bin/bash

    set -o errexit
    set -o nounset
    set -o pipefail

    echo "==> Started: $0"

    generate_pcp_conf_file() {
      echo "Generating pcp.conf file for Pgpool admin user (${PGPOOL_ADMIN_USERNAME})..."
      local passwd

      passwd=$(pg_md5 "$PGPOOL_ADMIN_PASSWORD")
      cat >>"$PGPOOL_PCP_CONF_FILE"<<EOF
    $PGPOOL_ADMIN_USERNAME:$passwd
    EOF
    }

    generate_pcp_conf_file

    echo "==> Completed: $0"

{# --- init_pcppass.sh --- #}

  init_pcppass.sh: |
    #!/bin/bash

    set -o errexit
    set -o nounset
    set -o pipefail

    echo "==> Started: $0"

    echo "Generating $HOME/.pcppass file for Pgpool admin user (${PGPOOL_ADMIN_USERNAME})..."

    cat >>"$HOME/.pcppass"<<EOF
    localhost:*:${PGPOOL_ADMIN_USERNAME}:${PGPOOL_ADMIN_PASSWORD}
    EOF

    chmod 600 $HOME/.pcppass

    echo "==> Completed: $0"

{# --- libpgpool.sh --- #}

  libpgpool.sh: |
    #!/bin/bash
    #
    # Bitnami Pgpool library

    # shellcheck disable=SC1090,SC1091

    # Load Generic Libraries
    . /opt/bitnami/scripts/libfile.sh
    . /opt/bitnami/scripts/libfs.sh
    . /opt/bitnami/scripts/liblog.sh
    . /opt/bitnami/scripts/libnet.sh
    . /opt/bitnami/scripts/libos.sh
    . /opt/bitnami/scripts/libservice.sh
    . /opt/bitnami/scripts/libvalidations.sh

    ########################
    # Loads global variables used on pgpool configuration.
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   None
    # Returns:
    #   Series of exports to be used as 'eval' arguments
    #########################
    pgpool_env() {
        cat <<"EOF"
    # Format log messages
    MODULE=pgpool

    # Paths
    export PGPOOL_BASE_DIR="/opt/bitnami/pgpool"
    export PGPOOL_DATA_DIR="${PGPOOL_BASE_DIR}/data"
    export PGPOOL_CONF_DIR="${PGPOOL_BASE_DIR}/conf"
    export PGPOOL_ETC_DIR="${PGPOOL_BASE_DIR}/etc"
    export PGPOOL_LOG_DIR="${PGPOOL_BASE_DIR}/logs"
    export PGPOOL_TMP_DIR="${PGPOOL_BASE_DIR}/tmp"
    export PGPOOL_BIN_DIR="${PGPOOL_BASE_DIR}/bin"
    export PGPOOL_INITSCRIPTS_DIR=/docker-entrypoint-initdb.d
    export PGPOOL_CONF_FILE="${PGPOOL_CONF_DIR}/pgpool.conf"
    export PGPOOL_PCP_CONF_FILE="${PGPOOL_ETC_DIR}/pcp.conf"
    export PGPOOL_PGHBA_FILE="${PGPOOL_CONF_DIR}/pool_hba.conf"
    export PGPOOL_PID_FILE="${PGPOOL_TMP_DIR}/pgpool.pid"
    export PGPOOL_LOG_FILE="${PGPOOL_LOG_DIR}/pgpool.log"
    export PGPOOL_ENABLE_POOL_HBA="${PGPOOL_ENABLE_POOL_HBA:-yes}"
    export PGPOOL_ENABLE_POOL_PASSWD="${PGPOOL_ENABLE_POOL_PASSWD:-yes}"
    export PGPOOL_USER_CONF_FILE="${PGPOOL_USER_CONF_FILE:-}"
    export PGPOOL_PASSWD_FILE="${PGPOOL_PASSWD_FILE:-pool_passwd}"
    export PATH="${PGPOOL_BIN_DIR}:$PATH"

    # Users
    export PGPOOL_DAEMON_USER="pgpool"
    export PGPOOL_DAEMON_GROUP="pgpool"

    # Settings
    export PGPOOL_PORT_NUMBER="${PGPOOL_PORT_NUMBER:-5432}"
    export PGPOOL_BACKEND_NODES="${PGPOOL_BACKEND_NODES:-}"
    export PGPOOL_SR_CHECK_USER="${PGPOOL_SR_CHECK_USER:-}"
    export PGPOOL_SR_CHECK_PERIOD="${PGPOOL_SR_CHECK_PERIOD:-30}"
    export PGPOOL_SR_CHECK_DATABASE="${PGPOOL_SR_CHECK_DATABASE:-postgres}"
    export PGPOOL_POSTGRES_USERNAME="${PGPOOL_POSTGRES_USERNAME:-postgres}"
    export PGPOOL_ADMIN_USERNAME="${PGPOOL_ADMIN_USERNAME:-}"
    export PGPOOL_ENABLE_LDAP="${PGPOOL_ENABLE_LDAP:-no}"
    export PGPOOL_TIMEOUT="360"
    export PGPOOL_ENABLE_LOG_CONNECTIONS="${PGPOOL_ENABLE_LOG_CONNECTIONS:-no}"
    export PGPOOL_ENABLE_LOG_HOSTNAME="${PGPOOL_ENABLE_LOG_HOSTNAME:-no}"
    export PGPOOL_ENABLE_LOG_PER_NODE_STATEMENT="${PGPOOL_ENABLE_LOG_PER_NODE_STATEMENT:-no}"
    export PGPOOL_ENABLE_LOAD_BALANCING="${PGPOOL_ENABLE_LOAD_BALANCING:-yes}"
    export PGPOOL_ENABLE_STATEMENT_LOAD_BALANCING="${PGPOOL_ENABLE_STATEMENT_LOAD_BALANCING:-no}"
    export PGPOOL_DISABLE_LOAD_BALANCE_ON_WRITE="${PGPOOL_DISABLE_LOAD_BALANCE_ON_WRITE:-transaction}"
    export PGPOOL_MAX_POOL="${PGPOOL_MAX_POOL:-15}"
    export PGPOOL_HEALTH_CHECK_USER="${PGPOOL_HEALTH_CHECK_USER:-$PGPOOL_SR_CHECK_USER}"
    export PGPOOL_HEALTH_CHECK_PERIOD="${PGPOOL_HEALTH_CHECK_PERIOD:-30}"
    export PGPOOL_HEALTH_CHECK_TIMEOUT="${PGPOOL_HEALTH_CHECK_TIMEOUT:-10}"
    export PGPOOL_HEALTH_CHECK_MAX_RETRIES="${PGPOOL_HEALTH_CHECK_MAX_RETRIES:-5}"
    export PGPOOL_HEALTH_CHECK_RETRY_DELAY="${PGPOOL_HEALTH_CHECK_RETRY_DELAY:-5}"
    export PGPOOL_POSTGRES_CUSTOM_USERS="${PGPOOL_POSTGRES_CUSTOM_USERS:-}"
    export PGPOOL_POSTGRES_CUSTOM_PASSWORDS="${PGPOOL_POSTGRES_CUSTOM_PASSWORDS:-}"
    export PGPOOL_AUTO_FAILBACK="${PGPOOL_AUTO_FAILBACK:-no}"
    export PGPOOL_BACKEND_APPLICATION_NAMES="${PGPOOL_BACKEND_APPLICATION_NAMES:-}"
    export PGPOOLKEYFILE="${PGPOOLKEYFILE}"

    # SSL
    export PGPOOL_ENABLE_TLS="${PGPOOL_ENABLE_TLS:-no}"
    export PGPOOL_TLS_CERT_FILE="${PGPOOL_TLS_CERT_FILE:-}"
    export PGPOOL_TLS_KEY_FILE="${PGPOOL_TLS_KEY_FILE:-}"
    export PGPOOL_TLS_CA_FILE="${PGPOOL_TLS_CA_FILE:-}"
    export PGPOOL_TLS_PREFER_SERVER_CIPHERS="${PGPOOL_TLS_PREFER_SERVER_CIPHERS:-yes}"

    EOF
        if [[ -f "${PGPOOL_ADMIN_PASSWORD_FILE:-}" ]]; then
            cat <<"EOF"
    export PGPOOL_ADMIN_PASSWORD="$(< "${PGPOOL_ADMIN_PASSWORD_FILE}")"
    EOF
        else
            cat <<"EOF"
    export PGPOOL_ADMIN_PASSWORD="${PGPOOL_ADMIN_PASSWORD:-}"
    EOF
        fi
        if [[ -f "${PGPOOL_POSTGRES_PASSWORD_FILE:-}" ]]; then
            cat <<"EOF"
    export PGPOOL_POSTGRES_PASSWORD="$(< "${PGPOOL_POSTGRES_PASSWORD_FILE}")"
    EOF
        else
            cat <<"EOF"
    export PGPOOL_POSTGRES_PASSWORD="${PGPOOL_POSTGRES_PASSWORD:-}"
    EOF
        fi
        if [[ -f "${PGPOOL_SR_CHECK_PASSWORD_FILE:-}" ]]; then
            cat <<"EOF"
    export PGPOOL_SR_CHECK_PASSWORD="$(< "${PGPOOL_SR_CHECK_PASSWORD_FILE}")"
    EOF
        else
            cat <<"EOF"
    export PGPOOL_SR_CHECK_PASSWORD="${PGPOOL_SR_CHECK_PASSWORD:-}"
    EOF
        fi
        if [[ -f "${PGPOOL_HEALTH_CHECK_PASSWORD_FILE:-}" ]]; then
            cat <<"EOF"
    export PGPOOL_HEALTH_CHECK_PASSWORD="$(< "${PGPOOL_HEALTH_CHECK_PASSWORD_FILE}")"
    EOF
        else
            cat <<"EOF"
    export PGPOOL_HEALTH_CHECK_PASSWORD="${PGPOOL_HEALTH_CHECK_PASSWORD:-$PGPOOL_SR_CHECK_PASSWORD}"
    EOF
        fi
    }

    ########################
    # Validate settings in PGPOOL_* env. variables
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    pgpool_validate() {
        info "Validating settings in PGPOOL_* env vars..."
        local error_code=0

        # Auxiliary functions
        print_validation_error() {
            error "$1"
            error_code=1
        }

        if [[ -z "$PGPOOL_ADMIN_USERNAME" ]] || [[ -z "$PGPOOL_ADMIN_PASSWORD" ]]; then
            print_validation_error "The Pgpool administrator user's credentials are mandatory. Set the environment variables PGPOOL_ADMIN_USERNAME and PGPOOL_ADMIN_PASSWORD with the Pgpool administrator user's credentials."
        fi
        if [[ "$PGPOOL_SR_CHECK_PERIOD" -gt 0 ]] && { [[ -z "$PGPOOL_SR_CHECK_USER" ]] || [[ -z "$PGPOOL_SR_CHECK_PASSWORD" ]]; }; then
            print_validation_error "The PostrgreSQL replication credentials are mandatory. Set the environment variables PGPOOL_SR_CHECK_USER and PGPOOL_SR_CHECK_PASSWORD with the PostrgreSQL replication credentials."
        fi
        if [[ -z "$PGPOOL_HEALTH_CHECK_USER" ]] || [[ -z "$PGPOOL_HEALTH_CHECK_PASSWORD" ]]; then
            print_validation_error "The PostrgreSQL health check credentials are mandatory. Set the environment variables PGPOOL_HEALTH_CHECK_USER and PGPOOL_HEALTH_CHECK_PASSWORD with the PostrgreSQL health check credentials."
        fi
        if is_boolean_yes "$PGPOOL_ENABLE_LDAP" && { [[ -z "${LDAP_URI}" ]] || [[ -z "${LDAP_BASE}" ]] || [[ -z "${LDAP_BIND_DN}" ]] || [[ -z "${LDAP_BIND_PASSWORD}" ]]; }; then
            print_validation_error "The LDAP configuration is required when LDAP authentication is enabled. Set the environment variables LDAP_URI, LDAP_BASE, LDAP_BIND_DN and LDAP_BIND_PASSWORD with the LDAP configuration."
        fi

        if is_boolean_yes "$PGPOOL_ENABLE_LDAP" && (! is_boolean_yes "$PGPOOL_ENABLE_POOL_HBA" || ! is_boolean_yes "$PGPOOL_ENABLE_POOL_PASSWD"); then
            print_validation_error "pool_hba.conf authentication and pool password should be enabled for LDAP to work. Keep the PGPOOL_ENABLE_POOL_HBA and PGPOOL_ENABLE_POOL_PASSWD environment variables set to 'yes'."
        fi

        if is_boolean_yes "$PGPOOL_ENABLE_POOL_PASSWD" && { [[ -z "$PGPOOL_POSTGRES_USERNAME" ]] || [[ -z "$PGPOOL_POSTGRES_PASSWORD" ]]; }; then
            print_validation_error "The administrator's database credentials are required. Set the environment variables PGPOOL_POSTGRES_USERNAME and PGPOOL_POSTGRES_PASSWORD with the administrator's database credentials."
        fi

        if [[ -z "$PGPOOL_BACKEND_NODES" ]]; then
            print_validation_error "The list of backend nodes cannot be empty. Set the environment variable PGPOOL_BACKEND_NODES with a comma separated list of backend nodes."
        else
            read -r -a nodes <<<"$(tr ',;' ' ' <<<"${PGPOOL_BACKEND_NODES}")"
            for node in "${nodes[@]}"; do
                read -r -a fields <<<"$(tr ':' ' ' <<<"${node}")"
                if [[ -z "${fields[0]:-}" ]]; then
                    print_validation_error "Error checking entry '$node', the field 'backend number' must be set!"
                fi
                if [[ -z "${fields[1]:-}" ]]; then
                    print_validation_error "Error checking entry '$node', the field 'host' must be set!"
                fi
            done
        fi

        if is_boolean_yes "$PGPOOL_AUTO_FAILBACK"; then
            if  [[ -z "$PGPOOL_BACKEND_APPLICATION_NAMES" ]]; then
                print_validation_error "The list of backend application names cannot be empty. Set the environment variable PGPOOL_BACKEND_APPLICATION_NAMES with a comma separated list of backend nodes."
            fi

            read -r -a app_name_list <<<"$(tr ',;' ' ' <<<"${PGPOOL_BACKEND_APPLICATION_NAMES}")"
            read -r -a nodes_list <<<"$(tr ',;' ' ' <<<"${PGPOOL_BACKEND_NODES}")"
            if [[ ${app_name_list[@]} -ne ${nodes_list[@]} ]]; then
                print_validation_error "PGPOOL_BACKEND_APPLICATION_NAMES and PGPOOL_BACKEND_NODES lists should have the same length"
            fi
        fi

        if [[ -n "$PGPOOL_USER_CONF_FILE" && ! -e "$PGPOOL_USER_CONF_FILE" ]]; then
            print_validation_error "The provided PGPOOL_USER_CONF_FILE: ${PGPOOL_USER_CONF_FILE} must exist."
        fi

        local yes_no_values=("PGPOOL_ENABLE_POOL_HBA" "PGPOOL_ENABLE_POOL_PASSWD" "PGPOOL_ENABLE_LOAD_BALANCING" "PGPOOL_ENABLE_STATEMENT_LOAD_BALANCING" "PGPOOL_ENABLE_LOG_CONNECTIONS" "PGPOOL_ENABLE_LOG_HOSTNAME" "PGPOOL_ENABLE_LOG_PER_NODE_STATEMENT" "PGPOOL_AUTO_FAILBACK")
        for yn in "${yes_no_values[@]}"; do
            if ! is_yes_no_value "${!yn}"; then
                print_validation_error "The values allowed for $yn are: yes or no"
            fi
        done
        local positive_values=("PGPOOL_NUM_INIT_CHILDREN" "PGPOOL_MAX_POOL" "PGPOOL_CHILD_MAX_CONNECTIONS" "PGPOOL_CHILD_LIFE_TIME" "PGPOOL_CONNECTION_LIFE_TIME" "PGPOOL_CLIENT_IDLE_LIMIT" "PGPOOL_HEALTH_CHECK_PERIOD" "PGPOOL_HEALTH_CHECK_TIMEOUT" "PGPOOL_HEALTH_CHECK_MAX_RETRIES" "PGPOOL_HEALTH_CHECK_RETRY_DELAY")
        for p in "${positive_values[@]}"; do
            if [[ -n "${!p:-}" ]]; then
                if ! is_positive_int "${!p}"; then
                    print_validation_error "The values allowed for $p: integer greater than 0"
                fi
            fi
        done
        if ! [[ "$PGPOOL_DISABLE_LOAD_BALANCE_ON_WRITE" =~ ^(off|transaction|trans_transaction|always)$ ]]; then
            print_validation_error "The values allowed for PGPOOL_DISABLE_LOAD_BALANCE_ON_WRITE: off,transaction,trans_transaction,always"
        fi

        if ! is_yes_no_value "$PGPOOL_ENABLE_TLS"; then
            print_validation_error "The values allowed for PGPOOL_ENABLE_TLS are: yes or no"
        elif is_boolean_yes "$PGPOOL_ENABLE_TLS"; then
            # TLS Checks
            if [[ -z "$PGPOOL_TLS_CERT_FILE" ]]; then
                print_validation_error "You must provide a X.509 certificate in order to use TLS"
            elif [[ ! -f "$PGPOOL_TLS_CERT_FILE" ]]; then
                print_validation_error "The X.509 certificate file in the specified path ${PGPOOL_TLS_CERT_FILE} does not exist"
            fi
            if [[ -z "$PGPOOL_TLS_KEY_FILE" ]]; then
                print_validation_error "You must provide a private key in order to use TLS"
            elif [[ ! -f "$PGPOOL_TLS_KEY_FILE" ]]; then
                print_validation_error "The private key file in the specified path ${PGPOOL_TLS_KEY_FILE} does not exist"
            fi
            if [[ -z "$PGPOOL_TLS_CA_FILE" ]]; then
                warn "A CA X.509 certificate was not provided. Client verification will not be performed in TLS connections"
            elif [[ ! -f "$PGPOOL_TLS_CA_FILE" ]]; then
                print_validation_error "The CA X.509 certificate file in the specified path ${PGPOOL_TLS_CA_FILE} does not exist"
            fi
            if ! is_yes_no_value "$PGPOOL_TLS_PREFER_SERVER_CIPHERS"; then
                print_validation_error "The values allowed for PGPOOL_TLS_PREFER_SERVER_CIPHERS are: yes or no"
            fi
        fi

        # Custom users validations
        read -r -a custom_users_list <<<"$(tr ',;' ' ' <<<"${PGPOOL_POSTGRES_CUSTOM_USERS}")"
        read -r -a custom_passwords_list <<<"$(tr ',;' ' ' <<<"${PGPOOL_POSTGRES_CUSTOM_PASSWORDS}")"
        if [[ ${custom_users_list[@]} -ne ${custom_passwords_list[@]} ]]; then
            print_validation_error "PGPOOL_POSTGRES_CUSTOM_USERS and PGPOOL_POSTGRES_CUSTOM_PASSWORDS lists should have the same length"
        fi

        [[ "$error_code" -eq 0 ]] || exit "$error_code"
    }

    pgpool_attach_node() {
        local -r node_id=${1:?node id is missing}

        info "Attaching backend node..."
        PCPPASSFILE=$(mktemp /tmp/pcppass-XXXXX)
        export PCPPASSFILE
        echo "localhost:9898:${PGPOOL_ADMIN_USERNAME}:${PGPOOL_ADMIN_PASSWORD}" >"${PCPPASSFILE}"
        pcp_attach_node -h localhost -U "${PGPOOL_ADMIN_USERNAME}" -p 9898 -n "${node_id}" -w
        rm -rf "${PCPPASSFILE}"
    }

    ########################
    # Check pgpool health and attached offline backends when they are online
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   None
    # Returns:
    #   0 when healthy
    #   1 when unhealthy
    #########################
    pgpool_healthcheck() {
        info "Checking pgpool health..."
        if PGCONNECT_TIMEOUT=15 PGPASSWORD="${PGPOOL_POSTGRES_PASSWORD}" psql -U "${PGPOOL_POSTGRES_USERNAME}" -d postgres \
            -h "${PGPOOL_TMP_DIR}" -p "${PGPOOL_PORT_NUMBER}" -tA -c "SHOW pool_nodes;" >/dev/null; then
            # look up backiends that are marked offline
            for node in $(PGPASSWORD="${PGPOOL_POSTGRES_PASSWORD}" psql -U "${PGPOOL_POSTGRES_USERNAME}" -d postgres \
                -h "${PGPOOL_TMP_DIR}" -p "${PGPOOL_PORT_NUMBER}" -tA -c "SHOW pool_nodes;" | grep "down"); do
                node_id=$(echo "${node}" | cut -d'|' -f1)
                node_host=$(echo "${node}" | cut -d'|' -f2)
                if PGPASSWORD="${PGPOOL_POSTGRES_PASSWORD}" psql -U "${PGPOOL_POSTGRES_USERNAME}" -d postgres \
                    -h "${node_host}" -p "${PGPOOL_PORT_NUMBER}" -tA -c "SELECT 1" >/dev/null; then
                    # attach backend if it has come back online
                    pgpool_attach_node "${node_id}"
                fi
            done
        else
            return 1
        fi
    }

    ########################
    # Create basic pg_hba.conf file
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    pgpool_create_pghba() {
        local authentication={{ postgresql_role_config.specification.configuration.password_encryption }}
        local postgres_auth_line=""
        local sr_check_auth_line=""
        info "Generating pg_hba.conf file..."

        is_boolean_yes "$PGPOOL_ENABLE_LDAP" && authentication="pam pamservice=pgpool"
        if is_boolean_yes "$PGPOOL_ENABLE_POOL_PASSWD"; then
            postgres_auth_line="host     all             ${PGPOOL_POSTGRES_USERNAME}       all         {{ postgresql_role_config.specification.configuration.password_encryption }}"
        fi
        if [[ -n "$PGPOOL_SR_CHECK_USER" ]]; then
            sr_check_auth_line="host     all             ${PGPOOL_SR_CHECK_USER}       all         trust"
        fi

        cat >>"$PGPOOL_PGHBA_FILE" <<EOF
    local    all             all                            trust
    EOF

        if ! is_empty_value "$PGPOOL_TLS_CA_FILE"; then
            cat >>"$PGPOOL_PGHBA_FILE" <<EOF
    hostssl     all             all             0.0.0.0/0               cert
    hostssl     all             all             ::/0                    cert
    EOF
        fi

        cat >>"$PGPOOL_PGHBA_FILE" <<EOF
    $sr_check_auth_line
    $postgres_auth_line
    host     all             wide               all         trust
    host     all             pop_user           all         trust
    host     all             all                all         $authentication
    EOF
    }

    ########################
    # Modify the pgpool.conf file by setting a property
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   $1 - property
    #   $2 - value
    #   $3 - Path to configuration file (default: $PGPOOL_CONF_FILE)
    # Returns:
    #   None
    #########################
    pgpool_set_property() {
        local -r property="${1:?missing property}"
        local -r value="${2:-}"
        local -r conf_file="${3:-$PGPOOL_CONF_FILE}"
        replace_in_file "$conf_file" "^#*\s*${property}\s*=.*" "${property} = '${value}'" false
    }

    ########################
    # Add a backend configuration to pgpool.conf file
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    pgpool_create_backend_config() {
        local -r node=${1:?node is missing}
        local -r application="${2:-}"

        # default values
        read -r -a fields <<<"$(tr ':' ' ' <<<"${node}")"
        local -r num="${fields[0]:?field num is needed}"
        local -r host="${fields[1]:?field host is needed}"
        local -r port="${fields[2]:-5432}"
        local -r weight="${fields[3]:-1}"
        local -r dir="${fields[4]:-$PGPOOL_DATA_DIR}"
        local -r flag="${fields[5]:-ALLOW_TO_FAILOVER}"

        debug "Adding '$host' information to the configuration..."
        cat >>"$PGPOOL_CONF_FILE" <<EOF
    backend_hostname$num = '$host'
    backend_port$num = $port
    backend_weight$num = $weight
    backend_data_directory$num = '$dir'
    backend_flag$num = '$flag'
    EOF
        if [[ -n "$application" ]]; then
            cat >>"$PGPOOL_CONF_FILE" <<EOF
    backend_application_name$num = '$application'
    EOF
        fi
    }

    ########################
    #  Create basic pgpool.conf file using the example provided in the etc/ folder
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    pgpool_create_config() {
        local pool_passwd=""
        local i=0

        if is_boolean_yes "$PGPOOL_ENABLE_POOL_PASSWD"; then
            pool_passwd="$PGPOOL_PASSWD_FILE"
        else
            # Specifying '' (empty) disables the use of password file.
            # ref: https://www.pgpool.net/docs/latest/en/html/runtime-config-connection.html#GUC-POOL-PASSWD
            pool_passwd=""
        fi

        info "Generating pgpool.conf file..."
        # Configuring Pgpool-II to use the streaming replication mode since it's the recommended way
        # ref: http://www.pgpool.net/docs/latest/en/html/configuring-pgpool.html
        cp "${PGPOOL_BASE_DIR}/etc/pgpool.conf.sample-stream" "$PGPOOL_CONF_FILE"

        # Connection settings
        # ref: http://www.pgpool.net/docs/latest/en/html/runtime-config-connection.html#RUNTIME-CONFIG-CONNECTION-SETTINGS
        pgpool_set_property "listen_addresses" "*"
        pgpool_set_property "port" "$PGPOOL_PORT_NUMBER"
        pgpool_set_property "socket_dir" "$PGPOOL_TMP_DIR"
        pgpool_set_property "pcp_socket_dir" "$PGPOOL_TMP_DIR"
        # Connection Pooling settings
        # http://www.pgpool.net/docs/latest/en/html/runtime-config-connection-pooling.html
        [[ -n "${PGPOOL_NUM_INIT_CHILDREN:-}" ]] && pgpool_set_property "num_init_children" "$PGPOOL_NUM_INIT_CHILDREN"
        pgpool_set_property "max_pool" "$PGPOOL_MAX_POOL"
        [[ -n "${PGPOOL_CHILD_MAX_CONNECTIONS:-}" ]] && pgpool_set_property "child_max_connections" "$PGPOOL_CHILD_MAX_CONNECTIONS"
        [[ -n "${PGPOOL_CHILD_LIFE_TIME:-}" ]] && pgpool_set_property "child_life_time" "$PGPOOL_CHILD_LIFE_TIME"
        [[ -n "${PGPOOL_CONNECTION_LIFE_TIME:-}" ]] && pgpool_set_property "connection_life_time" "$PGPOOL_CONNECTION_LIFE_TIME"
        [[ -n "${PGPOOL_CLIENT_IDLE_LIMIT-}" ]] && pgpool_set_property "client_idle_limit" "$PGPOOL_CLIENT_IDLE_LIMIT"
        # Logging settings
        # https://www.pgpool.net/docs/latest/en/html/runtime-config-logging.html
        pgpool_set_property "log_connections" "$(is_boolean_yes "$PGPOOL_ENABLE_LOG_CONNECTIONS" && echo "on" || echo "off")"
        pgpool_set_property "log_hostname" "$(is_boolean_yes "$PGPOOL_ENABLE_LOG_HOSTNAME" && echo "on" || echo "off")"
        pgpool_set_property "log_per_node_statement" "$(is_boolean_yes "$PGPOOL_ENABLE_LOG_PER_NODE_STATEMENT" && echo "on" || echo "off")"
        [[ -n "${PGPOOL_LOG_LINE_PREFIX:-}" ]] && pgpool_set_property "log_line_prefix" "$PGPOOL_LOG_LINE_PREFIX"
        [[ -n "${PGPOOL_CLIENT_MIN_MESSAGES:-}" ]] && pgpool_set_property "client_min_messages" "$PGPOOL_CLIENT_MIN_MESSAGES"
        # Authentication settings
        # ref: http://www.pgpool.net/docs/latest/en/html/runtime-config-connection.html#RUNTIME-CONFIG-AUTHENTICATION-SETTINGS
        pgpool_set_property "enable_pool_hba" "$(is_boolean_yes "$PGPOOL_ENABLE_POOL_HBA" && echo "on" || echo "off")"
        # allow_clear_text_frontend_auth only works when enable_pool_hba is not enabled
        # ref: https://www.pgpool.net/docs/latest/en/html/runtime-config-connection.html#GUC-ALLOW-CLEAR-TEXT-FRONTEND-AUTH
        pgpool_set_property "allow_clear_text_frontend_auth" "$(is_boolean_yes "$PGPOOL_ENABLE_POOL_HBA" && echo "off" || echo "on")"
        pgpool_set_property "pool_passwd" "$pool_passwd"
        pgpool_set_property "authentication_timeout" "30"
        # File Locations settings
        pgpool_set_property "pid_file_name" "$PGPOOL_PID_FILE"
        pgpool_set_property "logdir" "$PGPOOL_LOG_DIR"
        # Load Balancing settings
        # https://www.pgpool.net/docs/latest/en/html/runtime-config-load-balancing.html
        pgpool_set_property "load_balance_mode" "$(is_boolean_yes "$PGPOOL_ENABLE_LOAD_BALANCING" && echo "on" || echo "off")"
        pgpool_set_property "black_function_list" "nextval,setval"
        pgpool_set_property "statement_level_load_balance" "$(is_boolean_yes "$PGPOOL_ENABLE_STATEMENT_LOAD_BALANCING" && echo "on" || echo "off")"
        # Streaming Replication Check settings
        # https://www.pgpool.net/docs/latest/en/html/runtime-streaming-replication-check.html
        pgpool_set_property "sr_check_user" "$PGPOOL_SR_CHECK_USER"
        pgpool_set_property "sr_check_password" "$PGPOOL_SR_CHECK_PASSWORD"
        pgpool_set_property "sr_check_period" "$PGPOOL_SR_CHECK_PERIOD"
        pgpool_set_property "sr_check_database" "$PGPOOL_SR_CHECK_DATABASE"
        # Healthcheck per node settings
        # https://www.pgpool.net/docs/latest/en/html/runtime-config-health-check.html
        pgpool_set_property "health_check_period" "$PGPOOL_HEALTH_CHECK_PERIOD"
        pgpool_set_property "health_check_timeout" "$PGPOOL_HEALTH_CHECK_TIMEOUT"
        pgpool_set_property "health_check_user" "$PGPOOL_HEALTH_CHECK_USER"
        pgpool_set_property "health_check_password" "$PGPOOL_HEALTH_CHECK_PASSWORD"
        pgpool_set_property "health_check_max_retries" "$PGPOOL_HEALTH_CHECK_MAX_RETRIES"
        pgpool_set_property "health_check_retry_delay" "$PGPOOL_HEALTH_CHECK_RETRY_DELAY"
        # Failover settings
        pgpool_set_property "failover_command" "echo \">>> Failover - that will initialize new primary node search!\""
        pgpool_set_property "failover_on_backend_error" "off"
        # Keeps searching for a primary node forever when a failover occurs
        pgpool_set_property "search_primary_node_timeout" "0"
        pgpool_set_property "disable_load_balance_on_write" "$PGPOOL_DISABLE_LOAD_BALANCE_ON_WRITE"
        # SSL settings
        # https://www.pgpool.net/docs/latest/en/html/runtime-ssl.html
        if is_boolean_yes "$PGPOOL_ENABLE_TLS"; then
            chmod 600 "$PGPOOL_TLS_KEY_FILE" || warn "Could not set compulsory permissions (600) on file ${PGPOOL_TLS_KEY_FILE}"
            pgpool_set_property "ssl" "on"
            # Server ciphers are preferred by default
            ! is_boolean_yes "$PGPOOL_TLS_PREFER_SERVER_CIPHERS" && pgpool_set_property "ssl_prefer_server_ciphers" "off"
            [[ -n $PGPOOL_TLS_CA_FILE ]] && pgpool_set_property "ssl_ca_cert" "$PGPOOL_TLS_CA_FILE"
            pgpool_set_property "ssl_cert" "$PGPOOL_TLS_CERT_FILE"
            pgpool_set_property "ssl_key" "$PGPOOL_TLS_KEY_FILE"
        fi

        # Backend settings
        read -r -a nodes <<<"$(tr ',;' ' ' <<<"${PGPOOL_BACKEND_NODES}")"
        if is_boolean_yes "$PGPOOL_AUTO_FAILBACK"; then
            pgpool_set_property "auto_failback" "on"

            read -r -a app_name <<<"$(tr ',;' ' ' <<<"${PGPOOL_BACKEND_APPLICATION_NAMES}")"
        fi

        for node in "${nodes[@]}"; do
            pgpool_create_backend_config "$node" "$(is_boolean_yes "$PGPOOL_AUTO_FAILBACK" && echo "${app_name[i]}")"
            ((i += 1))
        done

        if [[ -f "$PGPOOL_USER_CONF_FILE" ]]; then
            info "Custom configuration '$PGPOOL_USER_CONF_FILE' detected!. Adding it to the configuration file."
            cat "$PGPOOL_USER_CONF_FILE" >>"$PGPOOL_CONF_FILE"
        fi
    }

    ########################
    # Generates a password file for local authentication
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    pgpool_generate_password_file_md5() {
        if is_boolean_yes "$PGPOOL_ENABLE_POOL_PASSWD"; then
            info "Generating password file for local authentication..."

            pg_md5 --md5auth \
                   --config-file="$PGPOOL_CONF_FILE" \
                   --username="$PGPOOL_POSTGRES_USERNAME" "$PGPOOL_POSTGRES_PASSWORD"

            if [[ -n "${PGPOOL_POSTGRES_CUSTOM_USERS}" ]]; then
                read -r -a custom_users_list <<<"$(tr ',;' ' ' <<<"${PGPOOL_POSTGRES_CUSTOM_USERS}")"
                read -r -a custom_passwords_list <<<"$(tr ',;' ' ' <<<"${PGPOOL_POSTGRES_CUSTOM_PASSWORDS}")"

                index=0
                for user in "${custom_users_list[@]}"; do
                    pg_md5 -m --config-file="$PGPOOL_CONF_FILE" -u "$user" "${custom_passwords_list[$index]}"
                    ((index += 1))
                done
            fi
        else
            info "Skip generating password file due to PGPOOL_ENABLE_POOL_PASSWD = no"
        fi
    }

    pgpool_generate_password_file_sha() {
        if is_boolean_yes "$PGPOOL_ENABLE_POOL_PASSWD"; then
            info "Generating password file for local authentication..."

            pg_enc --update-pass \
                   --config-file=/opt/bitnami/pgpool/conf/pgpool.conf \
                   --enc-key=$(cat $PGPOOLKEYFILE) \
                   --username=$PGPOOL_POSTGRES_USERNAME $(cat $PGPOOL_POSTGRES_PASSWORD_FILE)

        else
            info "Skip generating password file due to PGPOOL_ENABLE_POOL_PASSWD = no"
        fi
    }

    pgpool_generate_password_file() {
        if [ {{ postgresql_role_config.specification.configuration.password_encryption }} == "md5" ]
        then
            pgpool_generate_password_file_md5
        elif [ {{ postgresql_role_config.specification.configuration.password_encryption }} == "scram-sha-256" ]
        then
            pgpool_generate_password_file_sha
        else
            echo "Provided not supported parameter password_encryption"
        fi  
    }

    ########################
    # Run custom initialization scripts
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    pgpool_custom_init_scripts() {
        if [[ -n $(find "$PGPOOL_INITSCRIPTS_DIR/" -type f -name "*.sh") ]]; then
            info "Loading user's custom files from $PGPOOL_INITSCRIPTS_DIR ..."
            find "$PGPOOL_INITSCRIPTS_DIR/" -type f -name "*.sh" | sort | while read -r f; do
                if [[ -x "$f" ]]; then
                    debug "Executing $f"
                    "$f"
                else
                    debug "Sourcing $f"
                    . "$f"
                fi
            done
        fi
    }

    ########################
    # Generate a password file for pgpool admin user
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    pgpool_generate_admin_password_file() {
        info "Generating password file for pgpool admin user..."
        local passwd

        passwd=$(pg_md5 "$PGPOOL_ADMIN_PASSWORD")
        cat >>"$PGPOOL_PCP_CONF_FILE" <<EOF
    $PGPOOL_ADMIN_USERNAME:$passwd
    EOF
    }

    ########################
    # Ensure Pgpool is initialized
    # Globals:
    #   PGPOOL_*
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    pgpool_initialize() {
        info "Initializing Pgpool-II..."

        # This fixes an issue where the trap would kill the entrypoint.sh, if a PID was left over from a previous run
        # Exec replaces the process without creating a new one, and when the container is restarted it may have the same PID
        rm -f "$PGPOOL_PID_FILE"

        # Configuring permissions for tmp, logs and data folders
        am_i_root && configure_permissions_ownership "$PGPOOL_TMP_DIR $PGPOOL_LOG_DIR" -u "$PGPOOL_DAEMON_USER" -g "$PGPOOL_DAEMON_GROUP"
        am_i_root && configure_permissions_ownership "$PGPOOL_DATA_DIR" -u "$PGPOOL_DAEMON_USER" -g "$PGPOOL_DAEMON_GROUP" -d "755" -f "644"

        pgpool_create_pghba
        pgpool_create_config
        pgpool_generate_password_file
        pgpool_generate_admin_password_file
    }

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: pgpool-config-files
  labels:
    app: pgpool
  namespace: {{ data.namespace }}
data:
  pgpool.conf: |
    # {{ ansible_managed }}
    # ----------------------------
    # pgPool-II configuration file
    # ----------------------------
    #
    # This file consists of lines of the form:
    #
    #   name = value
    #
    # Whitespace may be used. Comments are introduced with "#" anywhere on a line.
    #
    # The complete list of parameters and allowed values can be found in the
    # pgPool-II documentation.
    #
    # This file is read on server startup and when the server receives a SIGHUP
    # signal. If you edit the file on a running system, you have to SIGHUP the
    # server for the changes to take effect, or use "pgpool reload". Some
    # parameters require a server shutdown and restart to take effect.

    #------------------------------------------------------------------------------
    # CONNECTIONS
    #------------------------------------------------------------------------------

    # - pgpool Connection Settings -

    listen_addresses = '*'
                                      # Host name or IP address to listen on
    port = '{{ data.pgpool.env.PGPOOL_PORT_NUMBER | default('5432') }}'

    socket_dir = '/opt/bitnami/pgpool/tmp'

    reserved_connections = 0
                                      # Number of reserved connections.
                                      # Pgpool-II does not accept connections if over
                                      # num_init_chidlren - reserved_connections.


    # - pgpool Communication Manager Connection Settings -

    pcp_listen_addresses = '*'
                                      # Host name or IP address for pcp process to listen on
    pcp_port = 9898

    pcp_socket_dir = '/opt/bitnami/pgpool/tmp'

    listen_backlog_multiplier = 2
                                      # Set the backlog parameter of listen(2) to
                                      # num_init_children * listen_backlog_multiplier.
    serialize_accept = off
                                      # whether to serialize accept() call to avoid thundering herd problem

    # - Backend Connection Settings -

{% if data.pgpool.env.PGPOOL_BACKEND_NODES is undefined or data.pgpool.env.PGPOOL_BACKEND_NODES|lower == 'autoconfigured' %}
{%   for node in groups['postgresql'] %}
    backend_hostname{{ loop.index0 }} = '{{ hostvars[groups['postgresql'][loop.index0]].ansible_hostname }}'
                                      # Host name or IP address to connect to for backend {{ loop.index0 }}
    backend_port{{ loop.index0 }} = 5432
                                      # Port number for backend {{ loop.index0 }}
    backend_weight{{ loop.index0 }} = 1
                                      # Weight for backend {{ loop.index0 }} (only in load balancing mode)
    backend_data_directory{{ loop.index0 }} = '/opt/bitnami/pgpool/data'
                                      # Data directory for backend {{ loop.index0 }}
    backend_flag{{ loop.index0 }} = 'ALLOW_TO_FAILOVER'
                                      # Controls various backend behavior
                                      # ALLOW_TO_FAILOVER, DISALLOW_TO_FAILOVER
                                      # or ALWAYS_MASTER
    backend_application_name{{ loop.index0 }} = '{{ hostvars[groups['postgresql'][loop.index0]].ansible_fqdn }}'
                                      # walsender's application_name, used for "show pool_nodes" command
{%     if not loop.last %}{# add empty line as node separator #}

{%     endif %}
{%   endfor %}
{% else %}
    # PGPOOL_BACKEND_NODES={{ data.pgpool.env.PGPOOL_BACKEND_NODES }}

{%   set nodes = data.pgpool.env.PGPOOL_BACKEND_NODES.split(',') %}
{%   for node in nodes %}
{%     set fields = node.split(':') %}
    backend_hostname{{ loop.index0 }} = '{{ fields[1] }}'
                                      # Host name or IP address to connect to for backend {{ loop.index0 }}
    backend_port{{ loop.index0 }} = {{ fields[2] | default(5432, true) }}
                                      # Port number for backend {{ loop.index0 }}
    backend_weight{{ loop.index0 }} = {{ fields[3] | default(1, true) }}
                                      # Weight for backend {{ loop.index0 }} (only in load balancing mode)
    backend_data_directory{{ loop.index0 }} = '{{ fields[4] | default('/opt/bitnami/pgpool/data', true) }}'
                                      # Data directory for backend {{ loop.index0 }}
    backend_flag{{ loop.index0 }} = '{{ fields[5] | default('ALLOW_TO_FAILOVER', true) }}'
                                      # Controls various backend behavior
                                      # ALLOW_TO_FAILOVER, DISALLOW_TO_FAILOVER
                                      # or ALWAYS_MASTER
{%     if fields[6] is defined %}
    backend_application_name{{ loop.index0 }} = '{{ fields[6] }}'
                                      # walsender's application_name, used for "show pool_nodes" command
{%     endif %}
{%     if not loop.last %}{# add empty line as node separator #}

{%     endif %}
{%   endfor %}
{% endif %}

    # - Authentication -

{% set allow_clear_text_frontend_auth = 'off' %}
{% if data.pgpool.env.PGPOOL_ENABLE_POOL_HBA is defined and not data.pgpool.env.PGPOOL_ENABLE_POOL_HBA %}
{%   set pool_hba = 'off' %}
{% else %}
{%   set pool_hba = 'on' %}
{% endif %}
{% if data.pgpool.env.PGPOOL_ENABLE_POOL_PASSWD is defined and not data.pgpool.env.PGPOOL_ENABLE_POOL_PASSWD %}
{%   set pool_passwd = "" %}
{%   if pool_hba == 'off' %}
{%     set allow_clear_text_frontend_auth = 'on' %}
{%   endif %}
{% else %}
{%   set pool_passwd = data.pgpool.env.PGPOOL_PASSWD_FILE | default('pool_passwd') %}
{% endif %}

    enable_pool_hba = '{{ pool_hba }}'
                                      # Use pool_hba.conf for client authentication
    pool_passwd = '{{ pool_passwd }}'
                                      # File name of pool_passwd for md5 authentication.
                                      # "" disables pool_passwd.
    authentication_timeout = '30'
                                      # Delay in seconds to complete client authentication
                                      # 0 means no timeout.

    allow_clear_text_frontend_auth = '{{ allow_clear_text_frontend_auth }}'
                                      # Allow Pgpool-II to use clear text password authentication
                                      # with clients, when pool_passwd does not
                                      # contain the user password

    # - SSL Connections -

    ssl = off
                                      # Enable SSL support
                                      # (change requires restart)
    #ssl_key = './server.key'
                                      # Path to the SSL private key file
                                      # (change requires restart)
    #ssl_cert = './server.cert'
                                      # Path to the SSL public certificate file
                                      # (change requires restart)
    #ssl_ca_cert = ''
                                      # Path to a single PEM format file
                                      # containing CA root certificate(s)
                                      # (change requires restart)
    #ssl_ca_cert_dir = ''
                                      # Directory containing CA root certificate(s)
                                      # (change requires restart)

    ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'
                                      # Allowed SSL ciphers
                                      # (change requires restart)
    ssl_prefer_server_ciphers = off
                                      # Use server's SSL cipher preferences,
                                      # rather than the client's
                                      # (change requires restart)
    ssl_ecdh_curve = 'prime256v1'
                                      # Name of the curve to use in ECDH key exchange
    ssl_dh_params_file = ''
                                      # Name of the file containing Diffie-Hellman parameters used
                                      # for so-called ephemeral DH family of SSL cipher.

    #------------------------------------------------------------------------------
    # POOLS
    #------------------------------------------------------------------------------

    # - Concurrent session and pool size -

    num_init_children = 32
                                      # Number of concurrent sessions allowed
                                      # (change requires restart)
    max_pool = {{ data.pgpool.env.PGPOOL_MAX_POOL | default('15') }}{# to be consistent with bitmami image default, pgpool default is 4 #}
                                      # Number of connection pool caches per connection
                                      # (change requires restart)

    # - Life time -

    child_life_time = 300
                                      # Pool exits after being idle for this many seconds
    child_max_connections = 0
                                      # Pool exits after receiving that many connections
                                      # 0 means no exit
    connection_life_time = 0
                                      # Connection to backend closes after being idle for this many seconds
                                      # 0 means no close
    client_idle_limit = 0
                                      # Client is disconnected after being idle for that many seconds
                                      # (even inside an explicit transactions!)
                                      # 0 means no disconnection


    #------------------------------------------------------------------------------
    # LOGS
    #------------------------------------------------------------------------------

    # - Where to log -

    log_destination = 'stderr'
                                      # Where to log
                                      # Valid values are combinations of stderr,
                                      # and syslog. Default to stderr.

    # - What to log -

    log_line_prefix = '%t: pid %p: '   # printf-style string to output at beginning of each log line.

    log_connections = off
                                      # Log connections
    log_hostname = off
                                      # Hostname will be shown in ps status
                                      # and in logs if connections are logged
    log_statement = off
                                      # Log all statements
    log_per_node_statement = off
                                      # Log all statements
                                      # with node and backend informations
    log_client_messages = off
                                      # Log any client messages
    log_standby_delay = 'if_over_threshold'
                                      # Log standby delay
                                      # Valid values are combinations of always,
                                      # if_over_threshold, none

    # - Syslog specific -

    syslog_facility = 'LOCAL0'
                                      # Syslog local facility. Default to LOCAL0
    syslog_ident = 'pgpool'
                                      # Syslog program identification string
                                      # Default to 'pgpool'

    # - Debug -

    #log_error_verbosity = default          # terse, default, or verbose messages

    #client_min_messages = notice           # values in order of decreasing detail:
                                            #   debug5
                                            #   debug4
                                            #   debug3
                                            #   debug2
                                            #   debug1
                                            #   log
                                            #   notice
                                            #   warning
                                            #   error

    #log_min_messages = warning             # values in order of decreasing detail:
                                            #   debug5
                                            #   debug4
                                            #   debug3
                                            #   debug2
                                            #   debug1
                                            #   info
                                            #   notice
                                            #   warning
                                            #   error
                                            #   log
                                            #   fatal
                                            #   panic

    #------------------------------------------------------------------------------
    # FILE LOCATIONS
    #------------------------------------------------------------------------------

    pid_file_name = '/opt/bitnami/pgpool/tmp/pgpool.pid'
                                      # PID file name
                                      # Can be specified as relative to the"
                                      # location of pgpool.conf file or
                                      # as an absolute path
                                      # (change requires restart)
    logdir = '/opt/bitnami/pgpool/logs'
                                      # Directory of pgPool status file
                                      # (change requires restart)


    #------------------------------------------------------------------------------
    # CONNECTION POOLING
    #------------------------------------------------------------------------------

    connection_cache = on
                                      # Activate connection pools
                                      # (change requires restart)

                                      # Semicolon separated list of queries
                                      # to be issued at the end of a session
                                      # The default is 'ABORT; DISCARD ALL'
    reset_query_list = 'ABORT; DISCARD ALL'


    #------------------------------------------------------------------------------
    # REPLICATION MODE
    #------------------------------------------------------------------------------

    replication_mode = off


    #------------------------------------------------------------------------------
    # LOAD BALANCING MODE
    #------------------------------------------------------------------------------

{% if data.pgpool.env.PGPOOL_ENABLE_LOAD_BALANCING is defined and not data.pgpool.env.PGPOOL_ENABLE_LOAD_BALANCING %}
    load_balance_mode = 'off'
{% else %}
    load_balance_mode = 'on'
{% endif %}
                                      # Activate load balancing mode
                                      # (change requires restart)
    ignore_leading_white_space = on
                                      # Ignore leading white spaces of each query
    white_function_list = ''
                                      # Comma separated list of function names
                                      # that don't write to database
                                      # Regexp are accepted
    black_function_list = 'currval,lastval,nextval,setval'
                                      # Comma separated list of function names
                                      # that write to database
                                      # Regexp are accepted

    black_query_pattern_list = ''
                                      # Semicolon separated list of query patterns
                                      # that should be sent to primary node
                                      # Regexp are accepted
                                      # valid for streaming replicaton mode only.

    database_redirect_preference_list = ''
                                      # comma separated list of pairs of database and node id.
                                      # example: postgres:primary,mydb[0-4]:1,mydb[5-9]:2'
                                      # valid for streaming replicaton mode only.

    app_name_redirect_preference_list = ''
                                      # comma separated list of pairs of app name and node id.
                                      # example: 'psql:primary,myapp[0-4]:1,myapp[5-9]:standby'
                                      # valid for streaming replicaton mode only.
    allow_sql_comments = off
                                      # if on, ignore SQL comments when judging if load balance or
                                      # query cache is possible.
                                      # If off, SQL comments effectively prevent the judgment
                                      # (pre 3.4 behavior).

    disable_load_balance_on_write = 'transaction'
                                      # Load balance behavior when write query is issued
                                      # in an explicit transaction.
                                      # Note that any query not in an explicit transaction
                                      # is not affected by the parameter.
                                      # 'transaction' (the default): if a write query is issued,
                                      # subsequent read queries will not be load balanced
                                      # until the transaction ends.
                                      # 'trans_transaction': if a write query is issued,
                                      # subsequent read queries in an explicit transaction
                                      # will not be load balanced until the session ends.
                                      # 'always': if a write query is issued, read queries will
                                      # not be load balanced until the session ends.

    statement_level_load_balance = off
                                      # Enables statement level load balancing

    #------------------------------------------------------------------------------
    # MASTER/SLAVE MODE
    #------------------------------------------------------------------------------

    master_slave_mode = on
                                      # Activate master/slave mode
                                      # (change requires restart)
    master_slave_sub_mode = 'stream'
                                      # Master/slave sub mode
                                      # Valid values are combinations stream, slony
                                      # or logical. Default is stream.
                                      # (change requires restart)

    # - Streaming -

    sr_check_period = 10
                                      # Streaming replication check period
                                      # Disabled (0) by default
    sr_check_user = '{{ data.pgpool.env.PGPOOL_SR_CHECK_USER }}'
                                      # Streaming replication check user
                                      # This is neccessary even if you disable streaming
                                      # replication delay check by sr_check_period = 0
    sr_check_password = ''
                                      # Password for streaming replication check user
                                      # Leaving it empty will make Pgpool-II to first look for the
                                      # Password in pool_passwd file before using the empty password

    sr_check_database = 'postgres'
                                      # Database name for streaming replication check
    delay_threshold = 10000000
                                      # Threshold before not dispatching query to standby node
                                      # Unit is in bytes
                                      # Disabled (0) by default

    # - Special commands -

    follow_master_command = ''
                                      # Executes this command after master failover
                                      # Special values:
                                      #   %d = failed node id
                                      #   %h = failed node host name
                                      #   %p = failed node port number
                                      #   %D = failed node database cluster path
                                      #   %m = new master node id
                                      #   %H = new master node hostname
                                      #   %M = old master node id
                                      #   %P = old primary node id
                                      #   %r = new master port number
                                      #   %R = new master database cluster path
                                      #   %N = old primary node hostname
                                      #   %S = old primary node port number
                                      #   %% = '%' character

    #------------------------------------------------------------------------------
    # HEALTH CHECK GLOBAL PARAMETERS
    #------------------------------------------------------------------------------

    health_check_period = '30'
                                      # Health check period
                                      # Disabled (0) by default
    health_check_timeout = '10'
                                      # Health check timeout
                                      # 0 means no timeout
    health_check_user = '{{ data.pgpool.env.PGPOOL_SR_CHECK_USER }}'
                                      # Health check user
    health_check_password = ''
                                      # Password for health check user
                                      # Leaving it empty will make Pgpool-II to first look for the
                                      # Password in pool_passwd file before using the empty password

    health_check_database = ''
                                      # Database name for health check. If '', tries 'postgres' frist,
    health_check_max_retries = '5'
                                      # Maximum number of times to retry a failed health check before giving up.
    health_check_retry_delay = '5'
                                      # Amount of time to wait (in seconds) between retries.
    connect_timeout = 10000
                                      # Timeout value in milliseconds before giving up to connect to backend.
                                      # Default is 10000 ms (10 second). Flaky network user may want to increase
                                      # the value. 0 means no timeout.
                                      # Note that this value is not only used for health check,
                                      # but also for ordinary conection to backend.

    #------------------------------------------------------------------------------
    # FAILOVER AND FAILBACK
    #------------------------------------------------------------------------------

    failover_command = ''
                                      # Executes this command at failover

    failback_command = ''
                                      # Executes this command at failback.

    failover_on_backend_error = 'off'
                                      # Initiates failover when reading/writing to the
                                      # backend communication socket fails
                                      # If set to off, pgpool will report an
                                      # error and disconnect the session.

    detach_false_primary = off
                                      # Detach false primary if on. Only
                                      # valid in streaming replicaton
                                      # mode and with PostgreSQL 9.6 or
                                      # after.

    search_primary_node_timeout = '0'
                                      # Timeout in seconds to search for the
                                      # primary node when a failover occurs.
                                      # 0 means no timeout, keep searching
                                      # for a primary node forever.

    #------------------------------------------------------------------------------
    # ONLINE RECOVERY
    #------------------------------------------------------------------------------

    recovery_user = 'nobody'
                                      # Online recovery user
    recovery_password = ''
                                      # Online recovery password
                                      # Leaving it empty will make Pgpool-II to first look for the
                                      # Password in pool_passwd file before using the empty password

    recovery_1st_stage_command = ''
                                      # Executes a command in first stage
    recovery_2nd_stage_command = ''
                                      # Executes a command in second stage
    recovery_timeout = 90
                                      # Timeout in seconds to wait for the
                                      # recovering node's postmaster to start up
                                      # 0 means no wait
    client_idle_limit_in_recovery = 0
                                      # Client is disconnected after being idle
                                      # for that many seconds in the second stage
                                      # of online recovery
                                      # 0 means no disconnection
                                      # -1 means immediate disconnection

    auto_failback = off
                                      # Dettached backend node reattach automatically
                                      # if replication_state is 'streaming'.
    auto_failback_interval = 60
                                      # Min interval of executing auto_failback in
                                      # seconds.

    #------------------------------------------------------------------------------
    # WATCHDOG
    #------------------------------------------------------------------------------

    # - Disabled so watchdog related parameters have been removed -

    use_watchdog = off


    #------------------------------------------------------------------------------
    # OTHERS
    #------------------------------------------------------------------------------
    relcache_expire = 0
                                      # Life time of relation cache in seconds.
                                      # 0 means no cache expiration(the default).
                                      # The relation cache is used for cache the
                                      # query result against PostgreSQL system
                                      # catalog to obtain various information
                                      # including table structures or if it's a
                                      # temporary table or not. The cache is
                                      # maintained in a pgpool child local memory
                                      # and being kept as long as it survives.
                                      # If someone modify the table by using
                                      # ALTER TABLE or some such, the relcache is
                                      # not consistent anymore.
                                      # For this purpose, cache_expiration
                                      # controls the life time of the cache.
    relcache_size = 256
                                      # Number of relation cache
                                      # entry. If you see frequently:
                                      # "pool_search_relcache: cache replacement happend"
                                      # in the pgpool log, you might want to increate this number.

    check_temp_table = catalog
                                      # Temporary table check method. catalog, trace or none.
                                      # Default is catalog.

    check_unlogged_table = on
                                      # If on, enable unlogged table check in SELECT statements.
                                      # This initiates queries against system catalog of primary/master
                                      # thus increases load of master.
                                      # If you are absolutely sure that your system never uses unlogged tables
                                      # and you want to save access to primary/master, you could turn this off.
                                      # Default is on.
    enable_shared_relcache = on
                                      # If on, relation cache stored in memory cache,
                                      # the cache is shared among child process.
                                      # Default is on.
                                      # (change requires restart)

    relcache_query_target = master     # Target node to send relcache queries. Default is master (primary) node.
                                      # If load_balance_node is specified, queries will be sent to load balance node.
    #------------------------------------------------------------------------------
    # IN MEMORY QUERY MEMORY CACHE
    #------------------------------------------------------------------------------
    memory_cache_enabled = off
                                      # If on, use the memory cache functionality, off by default
                                      # (change requires restart)
    memqcache_method = 'shmem'
                                      # Cache storage method. either 'shmem'(shared memory) or
                                      # 'memcached'. 'shmem' by default
                                      # (change requires restart)
    memqcache_memcached_host = 'localhost'
                                      # Memcached host name or IP address. Mandatory if
                                      # memqcache_method = 'memcached'.
                                      # Defaults to localhost.
                                      # (change requires restart)
    memqcache_memcached_port = 11211
                                      # Memcached port number. Mondatory if memqcache_method = 'memcached'.
                                      # Defaults to 11211.
                                      # (change requires restart)
    memqcache_total_size = 67108864
                                      # Total memory size in bytes for storing memory cache.
                                      # Mandatory if memqcache_method = 'shmem'.
                                      # Defaults to 64MB.
                                      # (change requires restart)
    memqcache_max_num_cache = 1000000
                                      # Total number of cache entries. Mandatory
                                      # if memqcache_method = 'shmem'.
                                      # Each cache entry consumes 48 bytes on shared memory.
                                      # Defaults to 1,000,000(45.8MB).
                                      # (change requires restart)
    memqcache_expire = 0
                                      # Memory cache entry life time specified in seconds.
                                      # 0 means infinite life time. 0 by default.
                                      # (change requires restart)
    memqcache_auto_cache_invalidation = on
                                      # If on, invalidation of query cache is triggered by corresponding
                                      # DDL/DML/DCL(and memqcache_expire).  If off, it is only triggered
                                      # by memqcache_expire.  on by default.
                                      # (change requires restart)
    memqcache_maxcache = 409600
                                      # Maximum SELECT result size in bytes.
                                      # Must be smaller than memqcache_cache_block_size. Defaults to 400KB.
                                      # (change requires restart)
    memqcache_cache_block_size = 1048576
                                      # Cache block size in bytes. Mandatory if memqcache_method = 'shmem'.
                                      # Defaults to 1MB.
                                      # (change requires restart)
    memqcache_oiddir = '/var/log/pgpool/oiddir'
                                      # Temporary work directory to record table oids
                                      # (change requires restart)
    white_memqcache_table_list = ''
                                      # Comma separated list of table names to memcache
                                      # that don't write to database
                                      # Regexp are accepted
    black_memqcache_table_list = ''
                                      # Comma separated list of table names not to memcache
                                      # that don't write to database
                                      # Regexp are accepted
{% if data.pgpool.pgpool_conf_content_to_append is defined and data.pgpool.pgpool_conf_content_to_append %}
    {{ data.pgpool.pgpool_conf_content_to_append | indent(4) }}
{% endif %}

  pool_hba.conf: |
    # {{ ansible_managed }}

    # Built-in record
    # TYPE   DATABASE        USER{% for n in range(data.pgpool.env.PGPOOL_SR_CHECK_USER|length) %}{{" "}}{% endfor %}ADDRESS             METHOD
    host     all             {{ data.pgpool.env.PGPOOL_SR_CHECK_USER }}    127.0.0.1/32        trust

{% if data.pgpool.pool_hba_conf is defined and data.pgpool.pool_hba_conf and data.pgpool.pool_hba_conf|lower != 'autoconfigured' %}
    # Records from Epiphany configuration
    {{ data.pgpool.pool_hba_conf | indent(4) }}
{% else %}
    # Default configuration
    # TYPE   DATABASE        USER                   ADDRESS             METHOD
    host     all             all                    all                 md5
{% endif %}
