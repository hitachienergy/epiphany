---
# Upgrade procedure based on steps from: https://www.postgresql.org/docs/13/pgupgrade.html

- name: PostgreSQL | Upgrade
  block:
    - name: PostgreSQL | Include vars from 'postgresql' role
      include_vars:
        file: roles/postgresql/vars/main.yml

    - name: PostgreSQL | Include new version default variables
      include_vars:
        file: roles/postgresql/defaults/main.yml
        name: new_version

    - name: PostgreSQL | Include old version default variables
      include_vars:
        file: vars/postgresql.yml
        name: old_version

    - name: PostgreSQL | Get PostgreSQL version from data directory
      slurp:
        src: "{{ old_version.pg.data_dir[ansible_os_family] }}/PG_VERSION"
      register: slurp_pg_version

    - name: PostgreSQL | Assert PostgreSQL cluster in version {{ pg_old_version }} is present
      assert:
        that:
          - slurp_pg_version['content'] | b64decode | trim is version(pg_old_version, '==')
        fail_msg: PostgreSQL cluster in version '{{ pg_old_version }}' not found
        success_msg: PostgreSQL cluster in version '{{ pg_old_version }}' found
        quiet: true

    # Step: Install the new PostgreSQL binaries

    # Ubuntu: automatically creates 'main' cluster and starts postgresql services
    # RHEL/CentOS: cluster name is empty, service is not started
    - name: PostgreSQL | Install PostgreSQL packages
      package:
        name: "{{ _packages[ansible_os_family] }}"
        state: present
      vars:
        _packages:
          Debian:
            - postgresql-client-common
            - postgresql-common
            - "postgresql-client-{{ pg_new_version }}"
            - "postgresql-{{ pg_new_version }}"
          RedHat:
            - "postgresql{{ pg_new_version }}-server"
      module_defaults:
        yum: { lock_timeout: "{{ yum_lock_timeout }}" }

    # Step: Initialize the new PostgreSQL cluster (on Ubuntu done automatically)

    # This value is default but set explicitly to avoid errors
    - name: PostgreSQL | RedHat | Ensure that new data directory has correct permissions
      file:
        path: "{{ new_version.pg.data_dir[ansible_os_family] }}"
        state: directory
        owner: postgres
        group: postgres
        mode: u=rwx,g=,o= # Permissions should be u=rwx (0700) or u=rwx,g=rx (0750)

    - name: PostgreSQL | RedHat | Initialize database
      when: ansible_os_family == 'RedHat'
      command: "{{ new_version.pg.bindir[ansible_os_family] }}/initdb"
      become_user: postgres
      environment:
        PGDATA: "{{ new_version.pg.data_dir[ansible_os_family] }}"

    # Step: Install custom shared object files
    - name: Gather facts on packages
      package_facts:

    - name: PostgreSQL | Extensions | PgAudit | Include upgrade tasks
      include_tasks: postgresql/extensions/pgaudit.yml

    # Step: Adjust authentication
    # TODO: check if needed (probably no as there is a "peer" authentication in pg_hba.conf)

    # Step: Stop all servers
    # Standby nodes have to be stopped first. Check p.8 from https://www.postgresql.org/docs/13/pgupgrade.html

    - name: Set 'pg_is_repmgr_used' fact
      vars:
        _regex:
          Debian: "postgresql-{{ pg_old_version }}-repmgr"
          Redhat: "repmgr{{ pg_old_version }}-*"
      set_fact:
        pg_is_repmgr_used: "{{ ansible_facts.packages | join is match(_regex[ansible_os_family]) }}"

    - name: PostgreSQL | Get primary node
      when: pg_is_repmgr_used
      shell: |-
        set -o pipefail && \
        {{ old_version.repmgr.bindir[ansible_os_family] }}/repmgr cluster show \
          | awk 'BEGIN{FS="|"} {gsub(/ /,""); if ($3 == "primary") print $2}'
      changed_when: false
      register: pg_primary_found
      failed_when: pg_node_primary_found.rc != 0 or pg_node_primary_found.stdout == ""
      delegate_to: "{{ groups.postgresql[0] }}"
      run_once: true

    - name: PostgreSQL | Set 'pg_primary_node' fact
      set_fact:
        pg_primary_node: "{{ pg_primary_found.stdout | default (groups.postgresql[0]) }}"

    - name: PostgreSQL | Stop PostgreSQL services on standby nodes
      when: inventory_hostname != pg_primary_node
      <<: &stop_pg_services
        systemd:
          name: "{{ service_name }}"
          state: stopped
        loop_control:
          loop_var: service_name
        loop:
          - "{{ old_version.pg.service_name[ansible_os_family] }}"  # the same name for both versions
          - "{{ old_version.pg.instantiated_service_name[ansible_os_family] }}"
          - "{{ new_version.pg.instantiated_service_name[ansible_os_family] }}"

    - name: PostgreSQL | Stop PostgreSQL services on primary node
      when: inventory_hostname == pg_primary_node
      <<: *stop_pg_services

    # Step: Prepare for standby server upgrades (TODO: check p.8 from https://www.postgresql.org/docs/13/pgupgrade.html)

    - name: PostgreSQL | Extensions | Repmgr | Prepare for standby server upgrades
      # when: "'repmgr' in ansible_facts.packages | join"
      when: pg_is_repmgr_used
      block:
        - name: PostgreSQL | Extensions | Repmgr | Get latest checkpoint location
          shell: |-
            set -o pipefail && \
            {{ old_version.pg.bindir }}/pg_controldata -D {{ old_version.pg.data_dir }} \
              | awk 'BEGIN{FS=":"} {gsub(/ /,""); if (tolower($1) == "latestcheckpointlocation") print $2}'
          changed_when: false
          register: pg_checkpoint

        - name: PostgreSQL | Extensions | Repmgr | Assert that latest checkpoint location values match for all hosts
          assert:
            that: hostvars[pg_host]['pg_checkpoint'].stdout == pg_checkpoint.stdout
            fail_msg: "Latest checkpoint location mismatch on hosts {{ inventory_hostname }} and {{ pg_host }}"
            quiet: true
          loop_control:
            loop_var: pg_host
          loop: "{{ groups.postgresql }}"
          run_once: true

        - name: PostgreSQL | Extensions | Repmgr | Install new package for PostgreSQL {{ pg_new_version }}
          package:
            name: "{{ _packages[ansible_os_family] }}"
            state: present
          vars:
            _packages:
              # TODO: we control extension version for RHEL/CentOS but not for Ubuntu
              # Should be the same for all OS distributions? (the same for PgAudit)
              # If the latest version is installed, pg_new_version can be used here not to change it each version upgrade
              Debian: "postgresql-{{ pg_new_version }}-repmgr"
              RedHat: "repmgr{{ pg_new_version }}-5.2.1"
          module_defaults:
            yum: { lock_timeout: "{{ yum_lock_timeout }}" }

    # Step: Run pg_upgrade

    # TODO: check if we should copy other files from pg.config_dir (such as pg_ctl.conf or pg_ident.conf)
    - name: PostgreSQL | Copy PostgreSQL configuration files
      vars:
        _files:
          - pg_hba.conf
          - postgresql-epiphany.conf
          - postgresql.conf
        pg: "{{ new_version.pg }}" # used in postgresql.conf
      template:
        src: "roles/postgresql/templates/{{ file_name }}.j2"
        dest: "{{ new_version.pg.config_dir[ansible_os_family] }}/{{ file_name }}"
        owner: postgres
        group: postgres
        mode: u=rw,g=,o=
        backup: true
      loop_control:
        loop_var: file_name
      loop: "{{ _files }}"

    # TODO: use --check before running upgrade

    # TODO check the doc about performance notes - https://www.postgresql.org/docs/13/pgupgrade.html, --jobs for example
    - name: PostgreSQL | Upgrade primary node
      when: inventory_hostname == pg_primary_node
      block:
        - name: PostgreSQL | Run pg_upgrade
          become_user: postgres
          command: >-
            {{ new_version.pg.bindir[ansible_os_family] }}/pg_upgrade
              --old-datadir {{ old_version.pg.data_dir[ansible_os_family] }}
              --new-datadir {{ new_version.pg.data_dir[ansible_os_family] }}
              --old-bindir {{ old_version.pg.bindir[ansible_os_family] }}
              --new-bindir {{ new_version.pg.bindir[ansible_os_family] }}
              --old-options '-c config_file={{ old_version.pg.config_dir[ansible_os_family] }}/postgresql.conf'
              --new-options '-c config_file={{ new_version_config_dir }}/postgresql.conf -c hba_file={{ new_version_config_dir }}/pg_hba.conf'
              --socketdir /var/run/postgresql
          args:
            chdir: /var/log/postgresql  # to have logs in this dir
          vars:
            new_version_config_dir: "{{ new_version.pg.config_dir[ansible_os_family] }}" # to make the line above shorter

        - name: PostgreSQL | Start and enable new PostgreSQL service
          systemd:
            name: "{{ new_version.pg.service_name[ansible_os_family] }}"
            state: started
            enabled: true

        - name: Extensions | Repmgr | Register primary node
          become_user: postgres
          command: >-
            {{ repmgr.bindir[ansible_os_family] }}/repmgr primary register
              --superuser={{ specification.extensions.replication.privileged_user_name }}
              --force

    # Prevent old service from starting to avoid accidental starting by the parent service and standard port conflict
    - name: PostgreSQL | Mask old PostgreSQL service
      systemd:
        name: "{{ old_version.pg.instantiated_service_name[ansible_os_family] }}"
        masked: true

    # Step: Upgrade standby servers
    - name: PostgreSQL | Upgrade standby servers (clone standby node from primary and register)
      when: inventory_hostname != pg_primary_node
      block:
        - name: Extensions | Repmgr | Clone standby node with Repmgr
          become_user: postgres
          command: >-
            {{ new_version.repmgr.bindir[ansible_os_family] }}/repmgr standby clone
              -h {{ pg_primary_node }}
              -U {{ specification.extensions.replication.privileged_user_name }}
              -d {{ specification.extensions.replication.repmgr_database }} -p 5432 --force

        - name: PostgreSQL | Start and enable new PostgreSQL service
          systemd:
            name: "{{ pg.service_name[ansible_os_family] }}"
            state: started
            enabled: true

        - name: Extensions | Repmgr | Register node with Repmgr
          become_user: postgres
          command: >-
            {{ repmgr.bindir[ansible_os_family] }}/repmgr standby register --force
              --upstream-conninfo='host={{ pg_primary_node }},
                  user={{ specification.extensions.replication.replication_user_name }},
                  dbname={{ specification.extensions.replication.repmgr_database }},
                  connect_timeout=2'
              --upstream-node-id 1

    # TODO: check post-upgrade processing

  # TODO: check the doc about following steps - https://www.postgresql.org/docs/13/pgupgrade.html
  rescue:
    #- name: PostgreSQL | Remove OS-specific packages
    #  package:
    #    name: "{{ _packages[ansible_os_family] }}"
    #    state: absent
    #  vars:
    #    _packages:
    #      Debian:
    #        - "postgresql-client-{{ pg_new_version }}"
    #        - "postgresql-{{ pg_new_version }}"
    #        - "postgresql-{{ pg_new_version }}-pgaudit"
    #        - "postgresql-{{ pg_new_version }}-repmgr"
    #      RedHat:
    #        - "postgresql{{ pg_new_version }}-server"
    #        - "pgaudit15_{{ pg_new_version }}"
    #        - "repmgr{{ pg_new_version }}-5.2.1"
    #  module_defaults:
    #    yum: { lock_timeout: "{{ yum_lock_timeout }}" }

    - name: PostgreSQL | Rollback | Remove new data directory
      file:
        path: "{{ new_version.pg.data_dir[ansible_os_family] }}"
        state: absent

    - name: PostgreSQL | Rollback | Start and enable old PostgreSQL service
      systemd:
        name: "{{ service_name }}"
        state: started
        enabled: true
        masked: false
      loop_control:
        loop_var: service_name
      loop:
        - "{{ old_version.pg.service_name[ansible_os_family] }}"  # the same name for both versions
        - "{{ old_version.pg.instantiated_service_name[ansible_os_family] }}"
        - "{{ new_version.pg.instantiated_service_name[ansible_os_family] }}"

    - name: PostgreSQL | Fail upgrade with a note
      debug:
        msg: PostgreSQL upgrade failed, please check logs
      failed_when: true
