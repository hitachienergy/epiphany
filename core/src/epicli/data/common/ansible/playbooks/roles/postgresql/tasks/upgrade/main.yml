---
# Upgrade procedure based on steps from: https://www.postgresql.org/docs/13/pgupgrade.html

- name: PostgreSQL | Get information about installed packages as facts
  package_facts:
    manager: auto
  when: ansible_facts.packages is undefined

- name: PostgreSQL | Set 'pg_is_repmgr_used' fact
  set_fact:
    pg_is_repmgr_used: ansible_facts.packages[old_version.repmgr.package_name[ansible_os_family]] is defined

- name: PostgreSQL | Get primary node
  when: pg_is_repmgr_used
  become_user: postgres
  shell: |-
    set -o pipefail && \
    {{ old_version.repmgr.bin_dir[ansible_os_family] }}/repmgr cluster show \
      | awk 'BEGIN{FS="|"} {gsub(/ /,""); if ($3 == "primary") print $2}'
  changed_when: false
  register: pg_node_primary_found
  failed_when: pg_node_primary_found.rc != 0 or pg_node_primary_found.stdout == ""
  delegate_to: "{{ groups.postgresql[0] }}"
  run_once: true

- name: PostgreSQL | Set 'pg_primary_node' fact
  set_fact:
    pg_primary_node: "{{ pg_primary_found.stdout | default (groups.postgresql[0]) }}" # should be available for upgrade and rollback

- name: PostgreSQL | Upgrade
  block:
    - name: PostgreSQL | Include vars from 'postgresql' role
      include_vars:
        file: vars/main.yml

    - name: PostgreSQL | Include new version default variables
      include_vars:
        file: defaults/main.yml
        name: new_version

    - name: PostgreSQL | Include old version default variables
      include_vars:
        file: defaults/upgrade.yml
        name: old_version

    - name: PostgreSQL | Get PostgreSQL version from data directory
      slurp:
        src: "{{ old_version.pg.data_dir[ansible_os_family] }}/PG_VERSION"
      register: slurp_pg_version

    - name: PostgreSQL | Assert PostgreSQL cluster in version {{ pg_old_version }} is present
      assert:
        that:
          - slurp_pg_version['content'] | b64decode | trim is version(pg_old_version, '==')
        fail_msg: PostgreSQL cluster in version '{{ pg_old_version }}' not found
        success_msg: PostgreSQL cluster in version '{{ pg_old_version }}' found
        quiet: true

    # Step: Install the new PostgreSQL binaries

    # Ubuntu: automatically creates 'main' cluster and starts postgresql services
    # RHEL/CentOS: cluster name is empty, service is not started
    - name: PostgreSQL | Install PostgreSQL packages
      package:
        name: "{{ _packages[ansible_os_family] }}"
        state: present
      vars:
        _packages:
          Debian:
            - postgresql-client-common
            - postgresql-common
            - "postgresql-client-{{ pg_new_version }}"
            - "postgresql-{{ pg_new_version }}"
          RedHat:
            - "postgresql{{ pg_new_version }}-server"
      module_defaults:
        yum: { lock_timeout: "{{ yum_lock_timeout }}" }

    # Step: Initialize the new PostgreSQL cluster (on Ubuntu done automatically)

    # This value is default but set explicitly to avoid errors
    - name: PostgreSQL | RedHat | Ensure that new data directory has correct permissions
      file:
        path: "{{ new_version.pg.data_dir[ansible_os_family] }}"
        state: directory
        owner: postgres
        group: postgres
        mode: u=rwx,g=,o= # Permissions should be u=rwx (0700) or u=rwx,g=rx (0750)

    - name: PostgreSQL | RedHat | Initialize database
      when: ansible_os_family == 'RedHat'
      command: "{{ new_version.pg.bin_dir[ansible_os_family] }}/initdb"
      become_user: postgres
      environment:
        PGDATA: "{{ new_version.pg.data_dir[ansible_os_family] }}"

    # Step: Install custom shared object files

    - name: PostgreSQL | Extensions | PgAudit | Include upgrade tasks
      include_tasks: roles/postgresql/tasks/upgrade/extensions/pgaudit.yml

    # Step: Adjust authentication

    - name: Extensions | repmgr | Create pgpass file
      template:
        src: roles/postgresql/templates/pgpass-repmgr.j2
        dest: "{{ new_version.pg.base_dir[ansible_os_family] }}/.pgpass"
        owner: postgres
        group: postgres
        mode: u=rw,g=,o=

    # Step: Stop all servers
    # Standby nodes have to be stopped after primary. Check p.8 from https://www.postgresql.org/docs/13/pgupgrade.html

    - name: PostgreSQL | Stop PostgreSQL services on standby nodes
      when: inventory_hostname == pg_primary_node
      <<: &stop_pg_services
        systemd:
          name: "{{ service_name }}"
          state: stopped
        loop_control:
          loop_var: service_name
        loop:
          - "{{ old_version.pg.service_name[ansible_os_family] }}"  # the same name for both versions
          - "{{ old_version.pg.instantiated_service_name[ansible_os_family] }}"
          - "{{ new_version.pg.instantiated_service_name[ansible_os_family] }}"

    - name: PostgreSQL | Stop PostgreSQL services on primary node
      when: inventory_hostname != pg_primary_node
      <<: *stop_pg_services

    # Step: Prepare for standby server upgrades

    - name: PostgreSQL | Extensions | repmgr | Prepare for standby server upgrades
      when: pg_is_repmgr_used
      block:
        - name: PostgreSQL | Extensions | repmgr | Get latest checkpoint location of primary node
          become_user: postgres
          shell: |-
            set -o pipefail && \
            {{ old_version.pg.bin_dir[ansible_os_family] }}/pg_controldata -D {{ old_version.pg.data_dir[ansible_os_family] }} \
              | awk 'BEGIN{FS=":"} {gsub(/ /,""); if (tolower($1) == "latestcheckpointlocation") print $2}'
          delegate_to: "{{ pg_primary_node }}"
          run_once: true
          changed_when: false
          register: pg_checkpoint

        - name: PostgreSQL | Extensions | repmgr | Assert that latest checkpoint location values are the same
          when: inventory_hostname != pg_primary_node
          assert:
            that: hostvars[inventory_hostname]['pg_checkpoint'].stdout == pg_checkpoint.stdout
            fail_msg: "Latest checkpoint location mismatch on hosts {{ inventory_hostname }} and {{ pg_primary_node }}"
            quiet: true

        - name: PostgreSQL | Extensions | repmgr | Install new package(s) for PostgreSQL {{ pg_new_version }}
          package:
            name: "{{ _packages[ansible_os_family] }}"
            state: present
          vars:
            _packages:
              Debian:
                - "{{new_version.repmgr.package_name.Debian}}={{ new_version.repmgr.version.Debian + '-*' }}"
                - "repmgr-common={{ new_version.repmgr.version.Debian + '-*' }}"
              RedHat:
                - "{{new_version.repmgr.package_name.RedHat}}-{{ new_version.repmgr.version.RedHat }}"
          module_defaults:
            yum: { lock_timeout: "{{ yum_lock_timeout }}" }

    # Step: Run pg_upgrade

    # TODO: check if we should copy other files from pg.config_dir (such as pg_ctl.conf or pg_ident.conf)
    - name: PostgreSQL | Copy configuration files
      block:
        - name: PostgreSQL | Copy configuration files
          vars:
            _files:
              - pg_hba.conf
              - postgresql-epiphany.conf
              - postgresql.conf
            pg: "{{ new_version.pg }}" # used in postgresql.conf
          template:
            src: "roles/postgresql/templates/{{ file_name }}.j2"
            dest: "{{ new_version.pg.config_dir[ansible_os_family] }}/{{ file_name }}"
            owner: postgres
            group: postgres
            mode: u=rw,g=,o=
            backup: true
          loop_control:
            loop_var: file_name
          loop: "{{ _files }}"

        - name: Extensions | repmgr | Copy configuration file
          when: pg_is_repmgr_used
          block:
            - name: Extensions | repmgr | Get node id
              command: >-
                grep -Po '(?<=^node_id=)\d+' "{{ old_version.repmgr.config_dir[ansible_os_family] }}/repmgr.conf"
              register: pg_node_id
              changed_when: false

            - name: Extensions | repmgr | Copy configuration file
              template:
                src: roles/postgresql/templates/repmgr.conf.j2
                dest: "{{ new_version.repmgr.config_dir[ansible_os_family] }}/repmgr.conf"
                owner: postgres
                group: postgres
                mode: u=rw,g=,o=
              vars:
                node_id: "{{ pg_node_id.stdout }}"
                pg_bin_dir: "{{ new_version.pg.bin_dir[ansible_os_family] }}"
                pg_data_dir: "{{ new_version.pg.data_dir[ansible_os_family] }}"
                pg_service_name: "{{ new_version.pg.service_name[ansible_os_family] }}"
                repmgr_service_name: "{{ new_version.repmgr.service_name[ansible_os_family] }}"

    - name: PostgreSQL | Upgrade primary node
      when: inventory_hostname == pg_primary_node
      block:
        # --link is not used to be able to access old cluster once the new one is started after the upgrade
        # there is a preflight check to confirm that available disk space is enough
        # --clone is not used as only Btrfs and XFS file systems are supported for the current version
        # also with file copying there is an ability to create new data directory not on the same file system
        - name: PostgreSQL | Run pg_upgrade
          become_user: postgres
          block:
            # This check is not in the 'preflight' as at that stage new version is not available
            # Checks:
            #   * cluster versions
            #   * database user is the install user
            #   * database connection settings
            #   * prepared transactions
            #   * system-defined composite types in user tables
            #   * reg* data types in user tables
            #   * contrib/isn with bigint-passing mismatch
            #   * tables WITH OIDS
            #   * invalid "sql_identifier" user columns
            #   * presence of required libraries
            #   * database user is the install user
            #   * prepared transactions
            #   * new cluster tablespace directories
            - name: PostgreSQL | Run pg_upgrade with --check
              command: >-
                {{ new_version.pg.bin_dir[ansible_os_family] }}/pg_upgrade
                  --old-datadir {{ old_version.pg.data_dir[ansible_os_family] }}
                  --new-datadir {{ new_version.pg.data_dir[ansible_os_family] }}
                  --old-bindir {{ old_version.pg.bin_dir[ansible_os_family] }}
                  --new-bindir {{ new_version.pg.bin_dir[ansible_os_family] }}
                  --old-options '-c config_file={{ old_version.pg.config_dir[ansible_os_family] }}/postgresql.conf'
                  --new-options '-c config_file={{ new_version_config_dir }}/postgresql.conf -c hba_file={{ new_version_config_dir }}/pg_hba.conf'
                  --socketdir /var/run/postgresql
                  --jobs {{ ansible_processor_vcpus }}
                  --check
              register: pg_upgrade_check

            - name: PostgreSQL | Print pg_upgrade check output
              debug:
                var: pg_upgrade_check.stdout_lines

            - name: PostgreSQL | Run pg_upgrade
              command: >-
                {{ new_version.pg.bin_dir[ansible_os_family] }}/pg_upgrade
                  --old-datadir {{ old_version.pg.data_dir[ansible_os_family] }}
                  --new-datadir {{ new_version.pg.data_dir[ansible_os_family] }}
                  --old-bindir {{ old_version.pg.bin_dir[ansible_os_family] }}
                  --new-bindir {{ new_version.pg.bin_dir[ansible_os_family] }}
                  --old-options '-c config_file={{ old_version.pg.config_dir[ansible_os_family] }}/postgresql.conf'
                  --new-options '-c config_file={{ new_version_config_dir }}/postgresql.conf
                                 -c hba_file={{ new_version_config_dir }}/pg_hba.conf'
                  --socketdir /var/run/postgresql
                  --jobs {{ ansible_processor_vcpus }}
              register: pg_upgrade_run
              args:
                chdir: /var/log/postgresql  # to have logs in this dir

            - name: PostgreSQL | Extend log information
              vars:
                pg_upgrade_log_file: >-
                  /var/log/postgresql/pg-upgrade-{{ ansible_date_time.iso8601_basic_short | replace('T','-') }}.log
              block:
                - name: Print a note to check upgrade results
                  debug:
                    msg: >-

                      **************************************
                      Check {{ pg_upgrade_log_file }} on host {{ pg_primary_node }} for upgrade results
                      If pg_upgrade generated any .sql files, run them
                      **************************************

                - name: PostgreSQL | Create a log file with pg_upgrade result
                  copy:
                    content: "{{ pg_upgrade_run.stdout }}"
                    dest: "{{ pg_upgrade_log_file }}"
          vars:
            new_version_config_dir: "{{ new_version.pg.config_dir[ansible_os_family] }}" # to make command shorter

        - name: PostgreSQL | Start and enable new PostgreSQL service
          systemd:
            name: "{{ new_version.pg.service_name[ansible_os_family] }}"
            state: started
            enabled: true

        # WTF
        - name: Extensions | repmgr | Alter super user and replication user in PostgreSQL
          become_user: postgres
          vars:
            _users:
              - user: "{{ specification.extensions.replication.privileged_user_name }}"
                password: "{{ specification.extensions.replication.privileged_user_password }}"
              - user: "{{ specification.extensions.replication.replication_user_name }}"
                password: "{{ specification.extensions.replication.replication_user_password }}"
          postgresql_query:
            query: "ALTER USER {{ item.user }} WITH PASSWORD '{{ item.password }}'"
          loop: "{{ _users }}"
          no_log: true

        - name: Extensions | repmgr | Register primary node
          when: pg_is_repmgr_used
          become_user: postgres
          command: >-
            {{ new_version.repmgr.bin_dir[ansible_os_family] }}/repmgr primary register
              --superuser={{ specification.extensions.replication.privileged_user_name }}
              --force

    # Prevent old service from starting to avoid accidental starting by the parent service and standard port conflict
    - name: PostgreSQL | Mask old PostgreSQL service
      systemd:
        name: "{{ old_version.pg.instantiated_service_name[ansible_os_family] }}"
        masked: true

    # Step: Upgrade standby servers
    - name: PostgreSQL | Upgrade standby servers (clone standby node from primary and register)
      when: inventory_hostname != pg_primary_node
      block:
        - name: Extensions | repmgr | Clone standby node with repmgr
          become_user: postgres
          command: >-
            {{ new_version.repmgr.bin_dir[ansible_os_family] }}/repmgr standby clone
              -h {{ pg_primary_node }}
              -U {{ specification.extensions.replication.privileged_user_name }}
              -d {{ specification.extensions.replication.repmgr_database }} -p 5432 --force

        - name: PostgreSQL | Start and enable new PostgreSQL service
          systemd:
            name: "{{ pg.service_name[ansible_os_family] }}"
            state: started
            enabled: true

        - name: Extensions | repmgr | Register node with repmgr
          become_user: postgres
          command: >-
            {{ repmgr.bin_dir[ansible_os_family] }}/repmgr standby register --force
              --upstream-conninfo='host={{ pg_primary_node }},
                  user={{ specification.extensions.replication.replication_user_name }},
                  dbname={{ specification.extensions.replication.repmgr_database }},
                  connect_timeout=2'
              --upstream-node-id 1

    # Step: Reverting to old cluster
    #rescue:
    #- name: PostgreSQL | Remove OS-specific packages
    #  package:
    #    name: "{{ _packages[ansible_os_family] }}"
    #    state: absent
    #  vars:
    #    _packages:
    #      Debian:
    #        - "postgresql-client-{{ pg_new_version }}"
    #        - "postgresql-{{ pg_new_version }}"
    #        - "postgresql-{{ pg_new_version }}-pgaudit"
    #        - "postgresql-{{ pg_new_version }}-repmgr"
    #      RedHat:
    #        - "postgresql{{ pg_new_version }}-server"
    #        - "pgaudit15_{{ pg_new_version }}"
    #        - "repmgr{{ pg_new_version }}-5.2.1"
    #  module_defaults:
    #    yum: { lock_timeout: "{{ yum_lock_timeout }}" }

    #- name: PostgreSQL | Rollback | Remove new data directory
    #  file:
    #    path: "{{ new_version.pg.data_dir[ansible_os_family] }}"
    #    state: absent

    #- name: PostgreSQL | Rollback | Start and enable old PostgreSQL service on primary node
    #  when: inventory_hostname == pg_primary_node
    #  <<: &start_pg_services
    #    systemd:
    #      name: "{{ service_name }}"
    #      state: started
    #      enabled: true
    #      masked: false
    #    loop_control:
    #     loop_var: service_name
    #    loop:
    #      - "{{ old_version.pg.service_name[ansible_os_family] }}"  # the same name for both versions
    #      - "{{ old_version.pg.instantiated_service_name[ansible_os_family] }}"

    #- name: PostgreSQL | Rollback | Start and enable old PostgreSQL service on standby nodes
    #  when: inventory_hostname != pg_primary_node
    #  <<: *start_pg_services

    #- name: PostgreSQL | Fail upgrade with a note
    #  debug:
    #    msg: PostgreSQL upgrade failed, please check logs
    #  failed_when: true
